# 简介

- javascript(ECMAScript-标准)起于1995年，主要用于处理网页中前端验证（用户输入是否符合规则）、网页动态效果。浏览器中内置js，所以我们可以直接执行。
- 组成：ECMAScript、DOM（js操作网页）、BOM（js操作浏览器）
- 特点：
  - 解释型语言
  - 动态语言
  - 弱类型语言
  - 基于原型的面向对象
- js用于操作浏览器与网页，所以写在html中。
- prompt():弹出输入框，并返回输入值

# 内容

## 1.编写位置

- html组件绑定好的事件后。（如onclick、onload）

- head标签中的script中。

- 外部js文件中，然后在网页中进行引入。（写在外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制。）

  <head>
      <script src="js文件路径"></script>
  </head>
  
  

## 2.基本语法

- JS中严格区分大小写

- JS中每条语句以；结尾

- JS中会忽略多个空格与换行

- 变量声明：ｖａｒ声明一个变量。

- 标识符：

  －　可以含字符、数字、特殊字符。

  －　不能以数字开头。

  －　不能是ES中的关键字或保留字。

  －　一般使用驼峰命名法

  －　注意：JS底层保存鲍师傅时实际上采用的是Unicode编码。所以理论上讲，所有的ｕｔｆ－８中含有的内容都可以作为标识符。

### 2.1数据类型

- **基本数据类型：**
- String:字符串（使用引号引起来，单双都行。引号不能嵌套，双引号中不能放双引号，单引号中不能放单引号。如果要特殊字符需要使用\进行转义）
  - 在js字符串中输出Unicode编码："\u字符编码"(具体编码查看码表)
  - 而在html中输出Unicode编码：&#字符编码;（但是这里的需要十进制编码，原码表中使用的是16进制）
- Number：数值（包括整数和浮点数。）（js中支持使用直接写十六进制、八进制、二进制等进行赋值，但是输出都是采用10进制输出。不是所有浏览器都支持）
  - 如果数值超过了Number.MAX_VALUE就会返回Infinity—正无穷）（typeof infinity返回的也是一个Number）
  - 一个变量如果使用NaN进行赋值，表示它的值不是一个Number。但是typeof NaN 还是返回一个Number。（通常是非Number型变量进行Number运算操作后会返回这个值。）
  - Number.MIN_VALUE返回的是一个大于 0的最小值。
- Boolean：布尔值（true、false）
- Null：空值(其值只有一个，就是null，这个值专门用来表示一个为空的对象，使用typeof检查一个null值时，就会返回object。)
- Undefined：未定义（该类型值就一个undefined。声明了一个变量但是并不给它赋值时，默认值就是undefined，表示没有定义。因为js是动态语言，运行时才确定它的类型，如果你不给它赋值，它就不知道这个变量的类型，所以需要一个默认值。但是它不同于Java等语言。相当于仅仅声明变量并没有进行初始化。）使用typeof进行检查返回的是undefined。
- **引用数据类型：**
- Object:对象
- **类型运算符**：typeof(typeof 变量名。返回变量类型)
- 强制数据类型转换：主要是指讲其他类型转换为String、Number、Boolean
  - 转换为String：
    - 调用被转换数据类型的toString()方法。该方法返回方法执行结果。null、undefined不能调用toString方法。
    - 调用String(待转数据),，并将被转换的数据作为参数传递。这个可以转换null、undefined。（注：对于非null、undefined调用的是toString(),而这两者直接进行转换。）
  - 转换为Number：
    - 使用Number()函数。
      - 字符串转换为数值（如果含有非数字字符除 . 外，则返回NaN-不是数值型），如果字符串是空字符串或者是一个全是空格的字符串，那么转换为0。
      - 布尔值转换为数字，true转换为1，false转换为0。
      - null转换为数字0
      - undefined转换为数字NaN
  - 转换为Boolean
    - 数值转布尔，除了0和NaN,其余的都是转换为true。
    - 字符串转换为布尔，除了空串，其余的都是true。
    - null转换为false。
    - undefined也转换为false。
    - 对象引用转换为true
  - 专门转换字符串的函数：
    - parseInt():把一个字符串转换为一个整数。取出一个字符串中能有效转换为数值的部分进行转换。
    - parseFloat():把字符串转换为一个浮点数
    - 注意如果一个非字符串变量调用这个函数，那么会先将这个变量转换为字符串，然后再调用。
- [js中的强制转换规则 - 渣渣逆天 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhazhanitian/p/12599252.html)
- ![](\img\v2-f01910a666029bbb1683a1f93a9b6514_720w.jpg)

### 2.2运算符

- [【JavaScript基础】JS运算符及其优先级_DUMG-CSDN博客_js符号优先级](https://blog.csdn.net/qq_43971504/article/details/104021149)
- 优先级相同从左往右计算
- 对象 instanceof  类名 ： 检查是否是某个类的实例。
- typeof (运算操作数的类型并以字符串的形式返回)
- 算术运算符：+、-、*、/、%......（对于非数值使用算术运算符进行运算，会先将其转换为Number，然后再进行运算。）

  - 任何值与NaN进行算术运算，结果NaN。
  - 与字符串进行+,会进行字符串拼接，即使有不是字符串的值也会转换为字符串然后进行拼接。（仅有加法特例）
    - 1+2+"3"="33"(因为js是解释运行的所以，会先将前面的按照数值进行运算，然后遇见字符串，按照字符串进行拼接。)
- 一元运算符:

  - +:对数值没有任何影响（可以用来对非数值型进行隐式的数据转换。）
    - 1++“2”+3=6
  - -:对数值进行取反操作
  - ++:自增
    - d=20
    - d++ + ++d + d=20+22+22=64
  - --：自减
- 逻辑运算符：只对布尔值进行运算，如果不是就先转换为布尔值（同样可以利用这个隐式转换将非布尔型转换为布尔型。）

  - ！：非
  - &&：与（但是是短路与-就是能够确定的结果后续运算不会进行）
  - ||：或（是短路或）

  - 对于非布尔值的运算：（谁能确定最终的值，就返回谁）

    - 对于&&,如果转换后
    - 如果第一个值是true，返回第二个值
    - 如果第一个值是false，返回第一个值
    - 对于||,如果转换后
    - 如果第一个值为true，则直接返回返回第一个值
    - 如果第一个值是false，则返回第二个值
- 赋值运算符：
  - =
  - +=
  - -=
  - *=
  - /=
  - %=
- 关系运算符：
  - <、>、<=、>=
- 相等运算符：
  - ==（undefined与null相等，null不等于0，NaN不和任何值相等包括其本身。所以只能通过isNaN()判断是否为NaN）
  - ！=
  - ===全等（会先判断类型，如果类型不同直接返回false，然后判断值）
  - ！==不全等
- 条件运算符：
  - ？：
- 运算符优先级：
  - 使用逗号分割一条语句，通常多个变量声明时使用。

### 2.3语句

- {}代码块

- ；每条语句结尾

- 顺序代码块

- 分支代码块

  - if(条件表达式){}

  - else if(){}

  - else{}

  - switch：

    - switch（条件表达式）{

      case 表达式：语句；break;

      case 表达式：语句；break;

      default 表达式：语句；break;

      }

- 循环代码块

  - while(条件表达式){循环体}
  - do{}while()
  - for（；；）{}
  - break、continue

### 2.4对象

- 内置对象：

  - 由ES标准中定义的对象，在任何的ES的实现中都可以使用。
  - String、Math、Number、Boolean、Function、Object

- 宿主对象：

  - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
  - 比如BOM、DOM

- 自定义对象

- 对象操作

  －　创建对象：ｎｅｗ　构造函数（）；

  　　－　ｖａｒ　ｏｂｊ＝ｎｅｗ　Object（）；

  －　添加对象属性：对象名．属性名＝属性值。

  －　读取对象属性：对象名．属性名（访问没有定义的属性不会报错，会返回undefined）

  －　修改属性一样，赋新值即可

  －　删除属性：delete　对象名．属性名

  －注：属性操作的点可以使用［］进行代替。而［］中可以使用变量来代替具体的属性名，从而使得变成灵活。
  
  - 使用字面量创建一个对象：
    - var obj={属性名：属性值，属性名：属性值......};
    - var obj={属性名：{}}相当于是将一个数组的引用赋给一个属性。
  
- 对象方法：

  - 因为对象属性可以时任意类型，所以也可以是函数，如果将一个属性定义为一个函数，就是对象方法。
  - 方法调用：对象名.属性名()

- 枚举对象属性：在给定一个对象后，进行枚举。

  - 这里包括方法也会被遍历，但是方法属性名其类型是string

    ```js
    for(var n in 对象){//n就是当前循环得到的属性名
        循环体
    }
    ```
    
    

- 通过工厂方法创建对象：

  - 因为js中没法定义类，只有对象，为了能够对同类对象批量生产，最好就是使用工厂方法模式进行创建。

  - ```js
    function factory(属性参数){
        var obj=new Object();
        //属性定义
        return obj;
    }
    ```
    
    

- 通过构造函数创建对象：可以说js是通过构造函数进行类的

  - 普通函数与构造函数的区别就是调用方式不同，普通函数直接调用，而构造函数需要使用new进行调用。

  - 使用new调用一个函数，会立即返回一个对象，这个对象在函数体中使用this表示,返回时返回的对象也是this。故在函数体中定义对象属性时，可以使用this进行定义。

    - ```js
      function Person(){
          this.name="sss";
      }
      var per=new Person();
      ```
      
      

- 对象中的原型prototype：

  - 我们所创建的每一个函数，解析器都会在函数中添加一个属性prototype。这个属性指向一个对象，这个兑现就是我们所谓的原型对象。我们可以通过_\_proto\_来访问该属性。（如：obj.\_proto\_，返回一个Object），只要时一个对象必然是会有这个属性，所以原型对象中同样有原型对象，直到这个原型的原型对象是null、undefined。
  - 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象。
  - 但是注意：当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有直接使用，如果美誉则会去原型对象中寻找，如果找到就直接使用。
  - 故使用for in检查对象中是否有某个属性时，也会在原型对象中查找。故要检查对象特有的属性时：就不能使用这个进行检测，需要使用hasOwnProperty()来检测特有属性，
    - 对象名.hasOwnProperty(属性名)；
  - 当在对象中找寻某个属性时，先在自身中寻找，没有就到原型中找，原型中没有就到原型的原型中找，直到原型为空。

- 一个类重写toString()方法：

  - ```js
    Person.prototype.toString=function(){
        return "......";
    }
    //因为要所有对象都适用，可以选择在构造函数中进行声明，也可以在prototype中进行声明。
    ```

    

- 未使用对象如果没有进行回收，会占据内存导致内存泄漏，大量的内存泄露导致内存溢出。所以需要垃圾回收机制：

  - js有自动垃圾回收机制。为了让垃圾回收器能快速准确的识别对于不使用的对象，最好将其引用进行置空，使得这块内存没有引用指向它。

### 2.5函数

- [js中(function(){…})()立即执行函数写法理解 - {前端开发} - 博客园 (cnblogs.com)](https://www.cnblogs.com/chris-oil/p/4862083.html)

- function（参数）{}

- 函数表达式：var 函数名=function（）{}。此时这个变量不是用来接收返回值的，而是用来给函数命名的。

  - (function(){console.log("a");})-----定义了一个匿名函数，可使用（）直接调用。

- js函数定义不会定义函数类型，调用函数时也不会检查函数类型调用时也不会检查传入参数的数量，如果有多余的参数不会被接收，如果参数数量少，则未传的被默认为undefined。

- 通过return设置返回值

  - 如果return语句后不跟任何值就相当于返回一个undefined。
  - 如果函数中不些return，则也会返回undefined。
  - return后可以跟任意类型的值。（空、对象、基本数据类型、函数.....）(所以js代码很灵活，些某些代码确实比较容易实现，比如回调函数、闭包。不像Java约束那么多)

- 将函数作为参数：函数也是一种对象。

  - ```js
    		var function1=function(){
      			console.log("a");
      		}
      		var function2=function(fun1){
      			fun1();
      		}
      		function2(function1);x 1        var function1=function(){2            console.log("a");3        }4        var function2=function(fun1){5            fun1();6        }7        function2(function1);js
    ```

    故在js中可以很好的理解闭包的概念。

- 立即执行函数：

  - （function(){函数体}）()；

### 2.6作用域

- 全局作用域
  - 直接编写在script标签中的js代码，都在全局作用域。
  - 全局作用域在页面打开时创建，在页面关闭时销毁。
  - 在全局作用域中有一个全局对象window，代表浏览器中窗口，我们可以直接使用。
  - 群居作用域中变量都是全局变量，在页面的任意部分都可以被访问到。
  - 在全局作用域中：
    - 创建的变量都会作为window对象的属性保存。
    - 创建的函数都会作为window对象的方法保存。
  - 变量声明提前：
    - 使用var关键字声明的变量，会在所有的代码执行之前被声明但是不会进行赋值，否则不会。可以理解为Java中的指令重排序。
  - 函数的声明提前：
    - 使用函数声明形式创建的函数function 函数名（）{}，会在所有代码执行之前就被创建，所以我们可以在函数声明前来调用函数。
    - 但是使用函数表达式var 变量名=function(){},仅仅只会提前声明变量，但是变量的值-函数地址，只有执行到具体声明处才会执行，所以我们不能在其前面直接调用。
- 函数作用域
  - 调用函数时创建函数作用域，函数执行完毕以后，函数作用销毁。
  - 每调用一次函数就会创建一个新的作用域，它们之间时相互独立的。
  - 函数作用域中，没有使用var声明的变量默认使用的是全局变量。
  - 函数的形参相当于就是使用了var进行声明。
  - 局部覆盖全局。
  - 在函数中要访问全局变量可以使用window对象。
- this：
  - 解析器在调用函数每次都会向函数内怒传递一个隐含的参数。这个隐含的参数就是this。可直接使用。
  - this指向的是一个对象：这个对象称为函数执行上下文对象，其实就是具体调用这个函数的对象。比如直接在全局中使用函数名调用，虽然没写具体的执行的对象，但实际上就是window对象。

### 2.7内建对象

- 数组：
  - var arr=new Array();
  - 使用字面量创建数组：var arr=[];
  - 同一个数组能够放任意类型的数据类型（基本数据类型、引用数据类型）。但是如果是null/undefined,则只会使用空位进行占据。
  - arr[索引]=值
  - 读取：arr[索引]。（如果读取不存在的索引，会返回undefined.）
  - 获取数组长度:length.(对于非连续的数组,数组的长度是最大索引值+1).同样我们可以主动修改这个长度,但是如果这个长度大于实际含有值的数量,那么其他位置则为用空进行占位.相反如果小于则会进行截断.
  - 数组方法：
    - push(元素,元素....):在该数组的末尾添加一个或多个元素，并返回数组新的长度。能够添加多个.
    - pop():删除数组最后一个元素并将该元素进行返回.
    - unshift():向数组开头添加一个或多个元素,并返回新的数组长度.
    - shift():删除数组的第一个元素,并将其返回.
    - slice(start,end):截取指定开始结束位置索引的元素片段到一个新数组中.并返回.不会影响元素组(截取部分:包括开始索引,不包括结束索引)
      - 索引可以传递负数,如果是负数,索引则从最后倒数进行计算.
    - splice(start,num,元素,元素.....):删除指定数组开始索引指定的数量的片段,然后将后面的元素从开始位置进行添加.(第一个指明开始的位置,第二个指明删除元素的数量.)
      - 故该方法能够用来删除\替换\添加.
    - concat(数组,数组,.....,元素,元素....):可以将多个数组或者元素连接在一起并返回一个新的数组.
    - join(连接符):可以将一个数组转换为一个字符串.
    - reverse()
      - 该方法用来反转数组.
      - 会影响原数组
    - sort():用于对数组排序
      - 对原数组有影响
      
      - 对于任何类型的元素其默认都是通过Unicode编码进行排序,也就是通过字符进行排序.
      
      - 所以我们需要自己制定规则.
      
        ```js
        var arr=[];
        arr,sort(function(a,b){});
        //a,b代表两个比较元素。浏览器默认升序排序。
        //如果回调函数返回1，表示a>b，则交换两者的位置
        //如果返回值-1，表示a<b，不交换。
        //返回0,表示相等
        //相当于Java中的比较器重写函数。
        ```
      
        
      
    
  - 数组遍历:
    - for
    - forEach()方法:之歌方法只支持IE8以上的浏览器.
      - 该方法需要一个函数作为参数:像这种函数,有我们创建但是不由我们调用的,我们称为回调函数.
      - 而数组中有几个元素机会执行这个回调函数几次.
      - 每次遍历浏览器会向回调函数中传递三个实参:
        - 当前遍历到的元素
        - 当前遍历到元素的索引位置
        - 当前遍历的数组
  
- 函数对象的方法：

  - 因为函数也是对象，那么它也有自己的方法。

  - 下面两者都能用来执行函数。且这两个方法不仅能够执行函数，且能够传入一个值，这个值是具体执行这个函数的对象。但是存在不同点。

    - call(调用对象，实参，实参)：可以挨个传入
    - apply(调用对象，[实参数组])：只能传入一个数组

  - 在调用函数时，浏览器每次都会传递尽两个隐含的参数：

    - 函数的上下文对象this

    - 封装实参的对象arguments

      - 因为一个函数并不会检查参数的数量，一个函数没有形参，但是如果你传入了参数，照样能够通过arguments找到。

      - arguments是一个类数组对象。虽然不是数组，但是其也可以通过索引进行数据操作。
      - arguments对象中有一个属性callee:这个属性对应一个函数对象，就是当前正指向的函数对象。

- Date对象：准确说时一个函数对象（类）

  - var date=new Date()；得到当前时间。
  - 创建一个指定时间：var da=new Date("12/03/2033 11:11:11")；
  - 属性：
  - 方法：
    - getDate()：获取当前日期对象的某月中的日。
    - getDay（）：返回当前日期是一周中的某一天。（0-6.0表示周日）
    - getMonth（)：返回月。（0-11）
    - getTime()：获取当前日期对象的时间戳（1970/1/1 00:00:00 到这个日期对象的毫秒数）（1秒=1000毫秒）
    - 计算机底层在保存时间时使用都是时间戳。（但是注意时区不同导致时间不同。）
    - Date.now()返回一个当前时间戳。

- Math：是一个Object对象。它不是一个构造函数，而是一个对象，工具类，就是定义一个对象，然后给他添加属性。

  - PI、E......
  - abs()
  - ceil()
  - floor()
  - round()：四舍五入
  - random（）：生成一个0-1之间的随机数(m+Math.random()*n)
  - max():多个数中的最大值
  - min()
  - pow(x,y):返回x的y次幂
  - sqrt():开方

- 包装类：主要用于当基本数据类型调用方法时，浏览器会临时将基本数据类型转换为包装类。因为是临时，所以不会进行维护，用完就丢。

  - 将基本数据类型转换为对象。

  - String（）：

    - 可以将基本数据类型字符串转换String对象。字符串底层使用的是字符数组进行保存，所以其实使用数组形式进行访问字符串。

    - 方法：

      - charAt(索引位置):返回指定位置（从0开始）的字符。
      - charCodeAt(索引位置):返回指定位置的字符的Unicode编码。
      - String.fromCharCode(十进制数):可以根据字符编码去获取字符。相当于提供了一个字符集查询器。
      - concat(字符串1，字符串2):可以连接字符串。
      - indexOf(模式，查找开始的索引):该方法可以检索一个字符串中是否含有，这个子字符串。并返回第一次出现的索引。没有则返回-1.
      - lastIndexOf:查找最后一次出现的位置。
      - slice（开始索引，结束索引）:截取字符串指定内容
      - substring:与slice类似，区别仅仅是，这个函数不能够解析负数索引，如果传入负数，默认设置为0，且如果第二个位置的索引小于第一个则会交换索引位置。
      - substr(开始位置，截取长度)：截取字符串。
      - split(分割符可以指定为正则表达式):将一个字符串拆分为一个数组。
      - toUpperCase():转换为大写返回一个新字符串
      - toLowerCase():转换为小写

    - 属性:length

    - 正则表达式：

      - 创建正则表达式：

        ```js
        var reg=new RegExp("正则表达式"，”匹配模式“);//该类型仍然是对象。
        reg.test("字符串");//使用这个正则表达式的对象进行检测字符串。返回true、false。
        匹配模式：（可以同时指定）
        	"i":表示忽略大小写
            ”g“：表示全局匹配
        ```

        

      - 使用字面量创建：var reg=/正则表达式/匹配模式

      - 表达式语法：

        - |:表示或
        - 【ab】:a或b
        - 【a-z】:任意小写字符
        - a【bdc】e:检查是否有abe/ade/ace
        - 【^ab】：检测除了ab之外的其他字符
        - a{3}:表示a要出现三次
        - （ab）{3}:表示ab同时出现3次
        - b{1,3}:表示b可以出现1，2，3三次
        - b+:b至少出现一次，相当于{1，}
        - b*:出现0个或者多个，相当于{0，}
        - b？:出现0个或1个，相当于{0，1}
        - ^a;表示以a开始的任意字符串
        - a$:表示以a结尾的字符串
        - ^a$:表示只能是a
        - ^a|$a：表示以a开头或者以a结尾
        - .：表示查找任意字符除了换行和行结束符。（但是特殊字符需要用转义，如：.，\）
          - \w:任意字母数字【A-z0-9】
          - \W：除了字母，数字【^A-z0-9】
          - \d:任意的数字
          - \D：除了数字
          - \s：空格
          - \S：除了空格
          - \b：单词边界（和空格差不多：/\bchild\b/）
          - \B：除了单词边界
        - 正则表达式验证手机号：^1【3-9】【0-9】{9}$
        - 邮箱地址：
          - 规则（任意字母下划线@任意字母数字.任意字母(2-5位).任意字母(2-5位)）
          - 分开写好写点
          - 常用正则表达式自己可以积累收藏下。

      - 与正则表达式相关的字符串函数：

        - split()
        - search(匹配模式):如果找到就返回第一次出现的索引，没有找到就返回-1.（即使设置g也只会查找一次）
        - match()
          - 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来。
          - 默认这个函数只会提取第一次符合规则的字符串。但是可以设置正则表达式的匹配模式：g那么就会返回所有匹配结果。而返回的结果是一个数组。
        - replace():
          - 可以将字符串指定内容替换为新的内容。
            - 参数：
              - 被替换的内容（正则表达式）
              - 新的内容

  - Number（）：将数字转换为Number对象。

  - Boolean（）：可以将布尔值转换为Boolean对象。

## 宿主对象

###3.DOM

#### DOM简介以及操作HTML组件以及事件绑定

- Document Object Modle文档对象模型

- js通过DOM来对HTML文档进行操作。

- 文档：就是整个HTML网页文档

- 对象：就是将网页中每一个部分都转换位一个对象（主要是标签）

- 模型：使用模型来表示对象之间的关系，这样方便我们获取对象。

- 节点：Node-构成HTML文档最基本的单元。

  - 常用节点：

    - 文档节点：整个HTML文档
    - 元素节点：HTML文档中的HTML标签
    - 属性节点：元素的属性
    - 文本节点：Html标签中的文本内容

  - 节点的属性：

    ![](\img\20220101091041.jpg)

  - 浏览器已经为我们提供文档节点，这个对象是window属性，可以在页面中直接使用，文档节点代表的是整个网页，作为我们访问所有节点的入口。

    - var obj=document.getElementById("id名");//获取到指定id的标签元素。
    - obj.innerHTML="";//修改标签对象的文本内容。对于自结束标签这个属性没有意义。如果这个标签对象中还有标签对象会一起被返回为一个字符串。（也就是将标签中间的所有文字作为字符串返回）
    - innerText：将文本全部拼接起来全部返回，如果还含有标签则不要标签只要标签中的文本。

  - 获取元素节点：通过document对象调用

    - getElementById():通过id属性获取一个元素节点对象。
    - getElementsByTagName():通过标签名获取一组元素节点对象。返回一个类数组对象，不是数组。
    - getElementsByName():通过name属性获取一组元素节点对象。返回一个类数组对象，不是数组。
    - 注意：读取元素节点的属性：元素.属性名（id,name,value）,读取class属性不能采用这种方式,需要使用：元素.className。

  - 获取元素节点的子节点：

    - 通过具体的元素节点调用
    - getElementsByTagName():返回当前节点的指定标签名后代节点
    - childNodes:表示当前节点的所有子节点。不仅仅是指元素，还有文本，比如换行符。
    - children:获取所有子节点，仅仅只有元素标签。不含文本。
    - firstChild:表示当前节点的第一个子节点。（包括文本）
    - firstElementChild：表示第一个非文本子节点。
    - lastChild:表示当前节点的最后一个子节点（包括文本）
    - lastElementChild：表示最后一个非文本子节点。
    
  - 获取元素的父节点和兄弟节点：

    - parentNode：表示当前节点的父节点
    - previousSibling：表示当前节点的前一个兄弟节点
    - nextSibling:表示当前节点的后一个兄弟节点

- 事件：（建议直接在js中为标签添加事件属性并绑定函数，不要在html标签中直接确定）

  - 就是文档或浏览器窗口中发生的一些特定的交互瞬间。

  - js与HTML之间的交互是通过事件实现的。

  - 对于web应用，常用事件：

    - 输入事件

      onblur - 当用户离开输入字段时

      onchange - 当用户更改输入字段的内容时

      onchange - 当用户选择下拉值时

      onfocus - 当输入字段获得焦点时

      onselect - 当输入文本被选取时

      onsubmit - 当用户点击提交按钮

      onreset - 当用户点击重置按钮

      onkeydown - 当用户按下/按住某个键时

      onkeypress - 当用户按下/按住某个键时

      onkeyup - 当用户释放按键时

      onkeyup - 当用户释放按键时

      onkeydown vs onkeyup - 两者

    - 鼠标事件

      onmouseover/onmouseout - 当鼠标经过一个元素时

      onmousedown/onmouseup - 当按下/释放鼠标按钮时

      onmousedown - 当按下鼠标时：提示点击了哪个元素

      onmousedown - 当点击鼠标时：提示点击了哪个按钮

      onmousemove/onmouseout - 当把鼠标指针移入/移出 div 时

      onmouseover/onmouseout - 当把鼠标指针移入/移出图像时

      onmouseover - 将鼠标悬停在图像映射上

    - 点击事件

      对 onclick 事件作出反应

      onclick - 单击按钮时

      ondblclick - 双击文本时

    - 加载事件

      onload - 页面加载后

      onload - 图像加载后

      onerror - 当图像加载时发生错误

      onunload - 当浏览器关闭文档时

      onresize - 当浏览器窗口大小被调整时
      
      onscroll-当滚动条滚动时触发
  
  - 注意：因为浏览器加载html时，是从上向下执行，如果js写在head中，会先执行js，而其他组件还没有被加载，那么如果js中调用未加载的组件只能获取到空对象。所以一般将js写在最后，css写在最前。如果要写在前面：可以在整个页面加载完成后执行。window.onload=function（）{js代码}；
  
  - 事件是给谁绑定的，那么绑定的这个函数执行时就是这个组件对象进行执行，this也就是它。
  
  - 其他：
  
    - document.documentElement保存的是html根标签。
    - document.all返回页面中所有的标签对象（从html根开始）。等价于document.getElementsByTagName("*")-通配符。
    - document.body获取body标签的对象
    - document.getElementsByClassName("类名")：通过类名获取标签对象。（IE8中没有）
    - document.querySelector():需要使用一个选择器的字符出作为参数，可以根据一个CSS选择器来查询一个元素节点对象。但是如果同个class存在多个，只会返回第一个（很强大的功能，IE8及以上）
    - document.querySelectorAll():同样使用方法，但是它返回所有也就是多个以数组对象返回。
  
- DOM增删改：

  - 创建元素节点：
    - var li=document.createElement("li");
  - 创建文本节点：
    - document.createTextNde("文本内容")；
  - 向一个父节点中添加子节点：
    - 父节点对象.appendChild(子节点对象);
    - 父节点对象.innerHTML+=“子节点标签”;
  - 在指定的子节点前插入新的子节点：
    - 父节点.insertBefore(待插入的新节点，指定的子节点);
  - 替换子节点
    - 父节点.replaceChild(新节点，被将替换的子节点)
  - 删除子节点
    - 父节点.removeChild(待删除的子节点)；
    - 不知道父节点的情况下：待删除节点.parentNode.removeChild(待删除子节点)
  
- 取消点击超链接的触发函数的默认行为，只需要js函数返回false就行。或者将href="javascript:;",而具体如何跳转完全交给超链接的点击函数。

- window.confirm（“显示信息”）:显示带有一段消息以及确认和取消按钮的对话框。

#### DOM操作CSS样式

- 通过js修改元素的样式：
  - 语法：元素对象.style.样式名=样式值
  - 对于样式名比较特殊的不能直接写样式名，需要做一定的变换，如：background-color中的-要转换为驼峰命名法，backgroundColor。
  - 注意：
    - js修改样式是通过style属性进行修改，而这个属性设置的样式是内联样式。内联样式有较高的优先级，所以通过修改的样式往往会立即显示。
    - 但是如果在样式中写了！important,则vi是样式会有最高的优先级，即使通过JS也不能覆盖该样式，这样会导致js修改样式修改失败，所以尽量不要为样式添加!important。
    - 通过style设置和读取到的都是内联样式。所以样式表中的样式无法读取。
  - 通过style获取到的样式是内联样式。所以如果是通过样式表设置或者使用外部样式文件设置的，那么就无法获取。
    - 获取当前元素的样式：
    - 元素名.currentStyle.样式名（但是只有IE支持）
    - 如果当前的样式名并没有样式，那么获取到的样式是样式的默认值，比如背景颜色的默认值是：transparent-透明。
    - 通过window.getComputeStyle()这个方法来获取元素当前样式。不支持IE8及以下的浏览器。
      - 参数：第一个参数-要获取样式的元素。第二个-可以传递一个伪元素，一般都传null
      - 该方法会返回一个样式对象，要获得具体的样式：样式对象.样式名。如果这个样式没有设置，则会获取到真实值，而不是默认值。
      - 注意：通过这个方式只能读取不能进行修改，要修改只能通过style.
  - 其他样式相关属性：
    - 元素名.clientWidth：获取元素的可见宽度（返回值不带px,返回的是数字，下同可以直接进行计算）
    - 元素名.clientHeight：获取元素的可见高度
    - 注：上面两者获取元素的高度和宽度，包括内容区、内边距不包括边框。且用于只读。
    - 下面两者在上面两者之上加入了边框。
    - 元素名.offsetWidth
    - 元素名.offsetHeight
    - 元素名.offsetParent
      - 可以用来获取当前元素的定位父元素。（获取的具体元素是离当前元素最近的开启了定位-position的祖先元素。）如果所有祖先元素都没有开启定位，那么获取的是body.
    - offsetLeft:当前元素相对于其定位父元素的水平偏移量。
    - offsetTop：当前元素相对于其定位父元素的垂直偏移量。
    - scrollHeight:获取整个元素滚动区域的高度
    - scrollWidth：获取整个元素滚动区域的宽度
    - scrollLeft:获取水平滚动的滚动距离
    - scrollTop：获取上下滚动的滚动的距离
    - scrollHeight-scrollTop==clientHeight。表示滚动条到底了。

#### DOM事件对象

- 当事件的相应函数触发时，浏览器每次都会将一个事件对象作为实参传递进相应函数。注意不是具体执行的组件对象（this），而是绑定好的这个事件对象。（但是IE8浏览器不会传递事件对象，而是作为window对象属性进行保存window.envent）

  - 在这个事件对象中封装了当前事件相关的一切信息。比如：鼠标的坐标、键盘哪个案件被按下、鼠标滚轮滚动的方向等。

  - clientX:可以获取鼠标指针的水平坐标

  - clientY：可以获取鼠标指针的垂直坐标

  - ```js
    	var objs=document.getElementById("as");
    	window.onmousemove=function(envent){
    		objs.innerText="x="+envent.clientX+"y="+envent.clientY;
    	}
    ```

  - 注意：上面两者的是相对于可见宽口的，也就是固定的值。不随滚动条变化而变化。但是div等元素的偏移量是相对于整个页面也就是document，如果给定一个绝对偏移量，它对于整个页面的位置就固定了，这时候如果滑动滚动条，它会随着整个页面而移动。

  - pageX、pageY。可以获取鼠标相对于当前页面的坐标。（IE8不支持，要达到目的就只有自己进行计算处理）

- 事件的冒泡：（其实就是有一点特征，子元素是父元素的一子部分，那么用户的事件操作子必然操作父。）

  - 假设有三个元素a,b,c，三个元素依次是父子关系，且都各自绑定了自己点击事件.现在我们触发c的点击事件，触发后发现b,a的点击事件也依次被触发了。这就是事件冒泡现象。（总之就是：触发孩子元素的事件，引发了祖先的同类事件被触发。也可能是孩子上没有，但是同样会触发祖先同类事件）
  - 如何取消冒泡：通过事件对象进行冒泡取消----事件对象.cancelBubble=true。（一旦孩子的冒泡取消了，那么其父节点的同类事件就不会被触发。）

- 事件的委派：将事件统一绑定给元素的共同的祖先元素。当后代元素事件触发时

  - 我们希望，只绑定依次事件，即可应用到多个元素上，即使元素是后添加的。
  - 可以尝试将其绑定给元素的共同祖先元素。因为存在冒泡，所以父事件一定会触发，即使是后添加的元素。
  - 通过委派可以减少事件的绑定的次数，提高程序的性能。
  - 但是如果父元素中含有我们不希望执行的子元素-比如必然有的文本节点。就需要判断，但是不能通过this对象进行判断，因为绑定的是父节点（有上转型的味道在里面）。
  - envent.target:可以获取到具体执行事件的对象。

- 事件的绑定：

  - 通过js:对象.事件=函数；绑定事件只能绑定一个事件，如果再次绑定先前的会被覆盖掉。（就像属性覆盖一样）
  - 通过addEnventListener():可以添加多个同类事件，这个函数是先绑定后执行。（IE8以下不支持，使用元素对象.attachEvent（“onclick”,fumction(){}）,先执行后绑定）
    - 参数：
      - 事件类型：就是"事件名"，但是不要on
      - 回调函数：就是要要触发的具体事件
      - 是否在捕获阶段触发事件：false/true
  - 注意：**addEnventListener**中的this是当前的元素对象，**attachEvent**中的this是window。
  
- 事件的传播：

  - 微软公司认为：事件应该是有内向外传播，也就是单赶时间触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播。也就是事件应该在冒泡阶段执行。
  - 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，先触发祖先事件再触发孩子事件。也就是应该再事件的捕获阶段执行。
  - W3标准，将事件传播分成3个阶段：（事件必然是操作者操作引起的，也就是用户操作事件是必然发生的，但是元素是否绑定某个事件是不确定的，所以需要捕获确定。）（IE8以下没有捕获阶段）
    - 捕获阶段：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件。（就是确定用户具体要操作的元素过程。）（这是一个确定元素的过程）
    - 目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件。（就是检测操作事件是否在捕获到的元素上绑定，如果有就执行）（这是检测并执行元素上是否绑定有用户操作事件的过程）
    - 冒泡阶段：将事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件。（这是回溯检测并执行祖先上是否绑定有用户操作事件的过程）
    - 如果希望在捕获阶段就触发事件，可以将addEnventListener()的第三个参数设置为true。一般情况下我们不会希望在捕获阶段触发事件。
  - 注意：当我们拖曳一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，如果不希望发生这个行为，则可以通过return false来取消默认行为。
  - 元素对象.setCapture():(只有IE支持)
    - 当一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上。注意仅仅生效一次。
    - 如果要取消捕获，使用：元素对象.releaseCapture().

- 鼠标滚轮事件：

  - onmousewheel:火狐不认。（要用DOMMouseScroll来绑定滚动事件。注意这个需要使用addEventListener函数来绑定。）
  - event,wheelDelta：可以获取鼠标滚轮滚动的方向。（正上，负下）（火狐中不支持：使用event.detail---正负反过来的）
  - 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动。这是浏览器的默认行为，如果不希望发生，则可以取消默认行为：return false。（而火狐需要使用event.preventDefault()取消默认行为。）

- 键盘事件：键盘事件一般都会绑定给一些可以获取到焦点的对象或是document对象。

  - onkeydown:按键被按下。
    - 如果按着按键不松手，则事件会已知触发。
    - 可以通过event.keyCode来获取按键的Unicode编码
    - event.altKey、ctrlKey、shiftKey：可以用于判断alt、ctrl、shift键是否被按下，如果按下则返回true，否则返回false。
    - 注：如果这个事件返回false，那么输入就不会到页面的焦点中。
  - onkeyup:按键被松开



### 4.BOM

- 浏览器对象模型
- 通过BOM，ｊｓ能够操作浏览器。
- Window：代表的时整个浏览器的窗口，同时window也是网页中的全局对象。而以下四个对象都是作为window对象的属性保存的。可以通过window来使用，也可以直接使用。
- Navigator：代表的当前地址栏的信息，通过该对象可以来识别不同的浏览器。
- Location：代表当前浏览器的地址栏信息
- History：代表浏览器的历史记录。由于隐私原因，该都西昂不能获取到具体的历史记录。只能操作浏览器向前或向后翻页。而且该操作只在档次访问时有效。
- Screen：代表用户的屏幕信息，通过该对象可以获取到用户的显示器的相关信息。



#### Navigator

- 由于历史原因，其大部分属性已经不能帮助我们识别浏览器了。
- appName:浏览器名称
- userAgent:一般只会使用userAgent来判断浏览器的信息。该属性就是一个字符串，该字符串中包含有用来描述浏览器信息的内容，不同的浏览器有不同的userAgent内容。
- 如果不能通过userAgent判断浏览器，还可以通过一些浏览器中特有的对象来判断浏览器的信息。比如IE特有的：window.ActiveXObject。但是IE11需要通过ActiveXObject in window才能够判断。



#### History

- history.length返回浏览器历史列表中url数量。(在IE中返回的是最近访问的url数量)
- history.back():可以用来回退到上一个页面，作用和浏览器的回退按钮一样。
- history.forward():可以跳转到前一个页面，作用与浏览器前进按钮一样。
- history.go():可以用来跳转到指定的页面，它需要作为一个整数作为参数。
  - go(2):向前跳转两个页面
  - go(-2):像后跳转两个页面

#### Location

- 直接打印location就是地址栏信息。
- 如果直接将location修改为一个绝对路径或相对路径，页面会自动进行跳转。并且会生成相应的历史记录。
- location的属性就是将url值分为几个部分
- assign(”url“):用来跳转到其他的页面，租用和直接修改location一样。
- reload(是否清空缓存进行刷新):用于重新加载当前页面，作用和刷新一样。true则清空缓存然后进行刷新。
- replace（”路径“）：可以使用一个页面替换当前页面，调用完毕也会跳转页面。但是先前的页面不会生成历史记录，不能使用回退进行回退。

#### 定时器

- 如果希望程序每隔一段事件就执行一次，可以使用定时器。
- setInterval():
  - 定时调用。将一个函数每隔一段时间被调用一次。
  - 参数
    - 要执行的函数
    - 每次调用间隔的时间，单位是毫秒。
  - 返回值
    - 返回一个Number类型的数据，这个数字用来作为定时器的唯一标识。
- clearInterval():用于关闭一个定时器
  - 需要一个定时器的标识作为参数。
  - 如果参数是一个有效的定时器的标识，则停止对应的定时器。不是什么也不发生。为了避免重复开启，可以先关再开启。
- setTimeout():延时调用
  - 延时调用一个函数不马上执行，而是隔一段时间后再执行。且只执行一次。
  - 参数
    - 执行函数
    - 延迟时间
- clearTimeout(延时器):关闭延时调用。
- 注意：延时调用与定时调用两者可以相互转换。

### 注意

- js能够通过改变类名后通过现有的css代码改变样式就改类名，否则才改变内联样式。



## JSON

- js中的数据类型只有js自己能够解析，为了保证数据能够在js语言与其他语言之间进行流畅的通信，需要一个中间体进行转换。JSON就是这样的中间体。

- JSON就是一种特殊格式的字符串。能够被任意语言所识别。（字符串在网络通过字节流进行传播，然后采用指定的字符集进行解析就能够得到完整的字符串内容。然后就能对字符串进行解析。）

- JavaScript　Object　Noｔation（ｊｓ对象表示法）。

- JSON与ｊｓ对象的格式一样，但是属性名必须加双引号，整体要是一个字符串。

- 分类：

  －　ＪＳＯＮ对象：｛｝

  －　ＪＳＯＮ数组：［］

- ＪＳＯＮ中允许的值：

  －　字符串

  －　数值

  －　布尔值

  －　ｎｕｌｌ

  －　对象

  －　数组

- 将JSOＮ字符串转换为JS中的对象。

  －　在JS中提供一个工具类，就叫JSON，这个对象能够将JSON字符串转换为JS对象，也能够将JS对象转换为JSON字符串。

  －　JSON．ｐａｒｓｅ（ｊｓｏｎ字符串）：可以将JSON字符串转换为ｊｓ对象。

  －　JSON．ｓｔｒｉｎｇｉｆｙ（ｊｓ对象）：可以将一个ｊｓ对象转换为JSON字符串。

  －　window．ｅｖａｌ（字符串）：这个函数能够执行字符串形式的ｊｓ代码。使用这个函数我们能够将ｊｓｏｎ字符串转换为ｊｓ对象并返回。

  －　JSON这个类还可以外部引入JSON．ｊｓ

