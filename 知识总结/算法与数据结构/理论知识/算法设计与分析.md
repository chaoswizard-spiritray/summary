# 算法设计与分析概述

## 1.算法定义

### 1.1

```tex
书籍推荐：Thomas H.Cormen等著的算法导论（第二版），机械工业出版社，2006
塞德维克，周良忠 译，C算法（第三版），人民邮电出版社，2004
卢开澄计算机算法导引：设计与分析
王晓东，计算机算法设计与分析
王晓东，算法设计与分析
```

### 1.2

```tex
程序=数据结构+算法
软件=程序+文档
算法不是问题的答案，而是经过准确定义以获得答案的过程，者整个过程就是答案。
算法是在有限步骤内求解某一问题所使用的一组定义明确的指令。
指令：有人或者物能够理解和执行的命令。
自认为：从数学角度看算法就是一个在一定定义域与值域上定义的函数。
```

- 算法五个特征：

  - 确定性（definiteness）：算法的每种运算必须要有确切的定义，不能有二义性，不能不满足客观世界的定义约束。（那么每条指令要有明确的意义，不存在不同的解读）
    - 5/0
    - 将6或者7与x相加
    - 未赋值变量参与运算
  - 可行性(effectiveness)：算法中有待实现的运算都是基本的运算，原理上每种运算都能有用纸和笔在“有限”时间内完成。
  - 输入（input）：每个算法有0~多个输入。这些输入时在算法开始之前各处的量，取自于特定的对象集合-定义域（或值域）。
  - 输出（output）：一个算法产生一个或者多个输出，这些输出是与输入有某种特定关系的量。
  - 有穷性（finiteness）：一个算法总是在执行了有穷步的运算之后终止。

- 计算过程：只满足确定性、可行性、输入、输出四个特此那个的一组规则。

- 算法与计算过程的区别：

  - 计算过程：操作系统（不终止的运行过程）
  - 算法是”可以终止的计算过程“
  - 算法的时效性：只能把在相当有穷步内终止的算法投入到计算机上运行。

- 算法要点

  - 算法的每一个步骤应该清晰，明确

  - 算法所处理的输入的定义域必须仔细定义

  - 同样的算法可以有多种描述形式

  - 可能存在几种解决相同问题的算法

  - 针对同一个问题的算法可能会基于完全不同的接替思路，而且解题的速度也会有明显区别。

  - 欧几里得算法：

    - gcd(m,n)=gcd(n,m mod n)=...=gcd(l,0)=l,l即为m和n的最大公约数。

  - 连续整数检测法（用大值除以小值，小值逐步减一，直至遍历出最大公约数）

    - 将min{m,n}赋值给t
    - m除以t，如果余数为0，进入第三步，否则进入第四步
    - n除以t，如果余数为0，返回t的值；否则进入第四步
    - 把t的值减一，返回第二步。

    ```tex
    质因数(因子为质数-最小的质数为2)分解法：
    1、找出m的所有质因数
    2、找出n的所有质因数
    3、从第一步求得的m的质因数分解式和第二部求得的n的质因数分解式中，找出所有公因数
    4、将第三步找到的公因数相乘，结构为所求gcd(m,n)
    连续质数序列筛选法：
    	-埃拉托色尼筛选法
    	1、初始化2~n的数组。
    	2、将质数的倍数置为0。
    	3、直到n的平方根结束（因为清除范围在n之内）
    ```
    
    


###  1.3算法设计分析典型步骤

- 理解问题

  ```tex
  就是要解决什么样的问题，比如排序问题还是查找问题，求最大值问题，甚至需要我们使用数学分析工具进行分析。
  ```

  

- 了解计算设备的性能（有些问题是有些计算机不能进行解决的）

  - 主流的计算机是冯诺依曼体系结构的计算机，程序指令是顺序执行的，设计的算法是串行算法，即指令逐条运行，每次执行一步操作。
  - 还有并行计算机，以及并行算法。指令能够并行的执行，效率会大大提高，额外需要考虑的是指令**执行顺序**以及**同步**问题-同步问题涉及问题比较多，比如缓存数据一致性问题，多线程并发问题。
  - 并行计算机的定义：有多个处理器单元（cpu）组成的计算机系统（非操作系统），这些处理单元相互通信和写作能快速、高效的求解大型复杂问题。（所以我们现在的多核cpu的冯诺依曼体系结构的计算机、分布式计算机、计算机网络，应该算是并行计算机）
  - 处理海量数据或对时间敏感的应用，需要认识到特定计算机系统的速度和存储限制。

  

- 在精确解法和近似解法间做选择（更具具体的场景选取，需要考虑诸多因素）

  - 并不是所有问题都有精确的算法，比如求平方根，微积分，非线性方程（计算机数值计算）
  - 还有的问题可能有精确解法但是使用该算法的代价很高，可能几十年，可能几万台服务器。

- 确定适当的数据结构（根据不同需求使用适应的数据结构，可以简化算法的实现，不同的数据结构可能有不同的算法实现或者是优化）

- 选取算法设计技术（或是称作范例）-针对某类问题比较好的前人的总结（经常采用的算法设计技术有：迭代法、穷举搜索法、递推法、递归法、贪婪法、回溯法、分治法、动态规划法、并行算法等，了解和借鉴这些算法设计的方法，有助于解决类似程序设计问题。）

- 详细表述算法的方法（不能产生二义性）

  - 自然描述
  - 伪代码描述
  - 程序流程图
  - 使用特定的编程语言进行描述

- 证明算法的正确性

  ```tex
  算法正确性指的是：对于任意合法的输入在有限时间内都能得到正确的结果。如果算法是一个近似算法，那么正确性则是指输出结果与理论结果之间的误差在一个可以接受的范围内。
  ```

  

- 分析算法

  - 时空观点：时间效率与空间效率
  - 发展观点：算法适应性强（一般性）
  - 设计观点：算法的设计时间最少
  - 交流观点：算法最容易理解（简单性）

- 为算法写代码（不同的编程语言适合于不同的方面，注意选取最适合的语言来实现算法，而且考虑到不同的语言特点，可以对算法的实现进行一些灵活变换。比如Matlab基于矩阵的语言，提供了大量的数值计算的函数，但是循环计算能力较弱。可以将循环计算转换为向量计算。）

<img src="..\图片\20210927210942.jpg" style="zoom:80%;" />



### 1.4 一般面临的问题类型（以后学习具体算法可以从这几块入手）

- 排序问题（sorting）

  - 将一组杂乱的数据按照一定的规律顺序排列起来
  - 排序算法有很多，但是并不存在一种算法是绝对最优的
  - 如果一个排序算法保留等值元素在输入中的相对顺序，则称算法是稳定的
  - 如果一个排序算法不需要额外的存储空间（除了个别存储单元外），则称算法是在位的。

- 查找/搜索问题（searching）

  - 查找/搜索实在数据集合中寻找满足某种条件的数据对象。一般的形式是先给出一个特定值，然后再数据集合中找出关键字等于该特定值的对象。
  - 返回的结果可能是搜索成功或者失败的信息
  - 返回满足搜索条件的对象所在位置，如果找不到则返回不存在信息。

- 字符串处理问题（string problems）

  - 字符串是字母表中符号构成的序列；文本串是有字母、数字、特殊符号锁构成的序列；位串是由0和1构成的序列。

  - 如字符串匹配问题，字符串匹配问题可看作一种特殊的搜索问题，因为它往往是匹配多个关键字，所以我们往往使用模式。（如正则表达式）。

- 图问题（graph problems）

  - 图问题指的是一些顶点与边的集合。图有着非常重要于丰富的实际应用，如通信网络，交通网络，工程计划、社会网络、经济网络等。
  - 如图的遍历、最短路径、环问题（度最小的环、是否存在环）
  - 树也算作图的问题，可以算作一种特例。

- 组合问题（combinatorial problems）

  - 如抽象代数、拓扑学、数学基础、图论、博弈论、线性规划
  - 该问题涉及领域广、涉及数据规模大，是计算领域最难的问题。

- 几何问题（geometric problems）

  - 几何数学上点、线、多边形相关的问题。
  - 如：计算机图形学、机器人技术、断层X摄像技术
  - 两个经典几何问题：
    - 最近邻点问题：求给定平面上的n个点中距离最近的两个点。
    - 凸包问题：找一个能把给定集合中所有点都包含再里面的最小凸多边形。

- 数值计算问题（numerical problems）

  - 涉及具有连续性的数学问题：求解方程或者方程组，求定积分、求函数的值等。
  - 这些问题往往只能给出一个近似的结果，而不是精确的解析解。并且这些问题常涉及到具体的数据，由于计算机对数字表示的精度问题，所以还需要考虑带来的误差以及这些误差对算法稳定性的影响。（比如哪些某些计算机表示数字的只能到小数点后几位。）

- 加密问题（encryption problems）

  - 加密问题是信息安全的基础
  - 要解决的问题：通信双方的相互鉴定，消息完整性的确定以及公开密钥的分发等。
  - 广泛的加密算法：DES算法、RSA算法以及MD５算法。

## 2.算法效率分析基础

### 2.1分析框架

- 效率分析

  - 时间效率：衡量其运行速度。
  - 空间效率：衡量算法运行需要占用空间的大小。
  - 硬件技术快速发展，存储容量的局限性对于算法的影响大大降低。但是时间效率并没有得到相同程度的提高。
  - 所以主要考虑的效率是时间效率。

- 输入规模的度量

  - 大部分算法的执行时间随着输入规模的增加而增大。如：数组排序，矩阵乘法、查找算法等。
  - 故从逻辑上说：算法的效率l应该是输入规模n的函数。

- 输入规模的具体参数选取方法

  - 例如：排序、查找】寻找列表的最小元素以及**其他与列表相关**的问题，输入规模就是列表的长度

  - 多项式
    $$
    p(x)=anx^n+...+a0求值问题，参数一般就是多项式的次数或者系数的个数
    $$
    
  - 矩阵乘法，参数选择矩阵的阶（方矩阵），或是矩阵中所有元素的个数（非方矩阵）作为输入规模
  
  - 有的算法需要根据讨论算法的操作袭击人，选择输入规模的合适量度
  
    - 拼写检查算法：
      - 如果算法对于输入的**每一个独立字符都要做检查**，应该使用字符的数量来度量输入规模。
      - 如果算法操作是以词为单位，应该使用词的数量来作为输入规模
      - 如果是句子，就应该使用句子。
  
- 运行时间的度量单位

  - 算法时间：编译时间、运行时间（往往只关注这个运行）
  - 衡量算法时间的单位：秒（s）、毫秒(ms)等。
  - 编译算法的时间与编译程序的好坏有关。
  - 仅考虑算法运行时间，也受到云心该算法的计算机速度的影响。因此**一个算法在某一台计算机上实现得到的时间对于其他计算机时没有参考意义的**。所以同一种算法的比较应该在同一台或是相同性能的计算机上来进行比较才具有意义。

- 如何通过输入规模n来衡量一个算法的运行时间l（也就是如何建立两者之间的函数。）

  - 假设我们统计每一步的执行次数，可行否？不可行，原因：对于一个算法，往往有些操作是主要性能消耗者（需要大量的循执行），有些仅仅只是执行一次，所以后者往往可以作为一个常量而忽略掉。（姑且认为算法也满足28定则吧）
  - 统计算法中最重要的操作-基本操作的执行次数
  - 基本操作通常是算法最内层循环中最费时的操作
    - 排序的基本操作：比较
    - 矩阵乘法的基本操作：乘法、加法
    - 多项式求值的基本操作：乘法、加法
    - 四则运算中，最耗时的是除法，其次乘法、最后是加法和减法（同级）。
  
- 算法时间效率的分析框架：统计算法的基本操作执行次数来对其效率进行度量。

  - 约定：

    - n：算法需要执行基本操作的次数

    - C(n)：算法需要执行基本操作的次数

    - Cop:特定计算机上一个算法基本操作的执行时间。那么该算法在该计算机上的运行时间：
      $$
      T(n)≈Cop*C(n)
      $$
      公式对于n非常大或者或者非常小，可以对算法的运行时间做合理的估计。

- 增长次数

  - 小规模的输入在运行时间上不能区分高效的算法与低效的算法，要考虑对于大规模输入时执行次数的增长次数

| n    | log2n | nlog2n   | n^2   | n^3   | 2^n       | n!         |
| ---- | ----- | -------- | ----- | ----- | --------- | ---------- |
| 10   | 3.3   | 3.3*10   | 10^2  | 10^3  | 10^3      | 3.6*10^6   |
| 10^2 | 6.6   | 6.6*10^2 | 10^4  | 10^6  | 1.3*10^30 | 3.6*10^157 |
| 10^3 | 10    | 1*10^4   | 10^6  | 10^9  |           |            |
| 10^5 | 17    | 1.7*10^6 | 10^10 | 10^15 |           |            |

- 后两者皆称为指数级增长

  - 一个一个需要指数级操作次数的算法只能用于输入规模极小的问题
  - 1<logn<n<nlogn<n^2<n^3<2^n<n!<n^n

- 函数中怎张最慢的时对数，最快的是阶乘。

- 对数级的基本操作次数

  - 程序对于任何实际规模的输入都会在几乎瞬间内完成

  - 当仅关注增长次数及其常数倍时，忽略对数的底
    $$
    logaN=logab*logbN
    $$
    
  - 

  输入规模为n时，算法在最坏情况下的效率

- 算法最优、最差和平均效率

  - 算法运行时间取决于输入规模和特定输入细节
  
  - 因为有具体输入细节原因，所以有最优最差平均之分
  
  - 最差效率：输入规模为n时，算法在最坏情况下的效率
  
  - 最优效率：输入规模为n时，算法在最优情况下的效率
  
  - 平均效率：在随机或典型输入时，算法效率
  
  - 平均效率的研究方法：一般将规模为n的实例分为几种类型，假设各种输入的概率分布推导出基本操作的平均次数。（往往是概率论中的期望值）
  
    <img src="..\图片\20210930085920.jpg" style="zoom:80%;" />
  
- 算法时间效率的衡量与空间效率都是输入量的函数

- 时间效率的衡量通过算法基本操作执行次数的估计进行，而空间效率的衡量是通过算法运行所占用额外的存储资源量进行的。

- 在输入规模相同的情况下，有些算法的效率会有显著差异，需要区分算法最差、平均、最优效率。（就是用来更准确的比较算法性能）

- 分析框架关系的是，当算法输入规模倾向于无限大时其运行时间（额外空间）函数的增长次数。

### 2.2渐进符号和基本效率类型

- 渐进符号
  - O
    - **存在常数c>0和非负整数n0,使得对所有n>=n0,有t(n)<=cg(n)**
    - 则称函数t(n)包含在O(g(n))中，记为t(n)∈O(g(n)).也称函数t(n)在n充分大时有上界，且t(n)的阶不高于g(n)的阶。
    - 上界的阶越低就越精确，结果就越有价值。（也就是尽量让两者的阶接近，下同）
    - t(n)=3n∈O(n),所以同阶必然满足，系数忽略。所以才说g(n)是一个阶数。
    
  - Ω(omiga)
    - **存在常数c>0和非负整数n0,使得对所有n>=n0,有t(n)>=cg(n)**
    - 则称函数t(n)包含在Ω(g(n))中，记为t(n)∈Ω(g(n)).也称函数t(n)在n充分大时有下界，且t(n)的阶不低于g(n)的阶。
    
  - Θ（theta）
  
    - 存在非负常数c1、c2和n0∈N,使得对所有n>=n0,有
      $$
      c1g(n)<=t(n)<=c2g(n)
      $$
      
      
      
    - 则称函数t(n)包含在Θ(g(n))中，记为t(n)∈他和Θ(g(n));也称函数t(n)在n充分大时有上界和下界
  
  - 约定的函数符号
    - n：算法输入规模
    - t(n)/T(n):非负函数，算法运行时间
    - g(n):用来和操作次数做比较的函数
    - C(n)：基本操作次数
    
  - 渐进符号简单定义
    - O(*g(n)*)：增长次数<=g(n)(c1*g(n),c1∈R，n->∞)的***函数集合**。（也就是g(n)是t(n)的上限）
    - Ω(*g(n)*)：增长次数>=g(n)(c2*g(n),c2∈R，n->∞)的***函数集合**。（也就是g(n)是t(n)的下限）
    - Θ(*g(n)*)：增长次数=g(n)(c3*g(n),c3∈R，n->∞)的***函数集合**。（也就是g(n)与t(n)同级数）（夹逼准则）
    
  - 定理(定理虽能快速定位上下界的范围，但是要更精确，还需要进行适当处理)
  
    - 如果t1(n)∈O(g1(n)),t2(n)∈O(g2(n)),则
      $$
      t1(n)+t2(n)∈O(max[g1(n),g2(n])
      $$
  
      
      
      ```tex
      证明放缩就行了，往上放大那肯定成立。
      ```
      
      
      
    - 对于Ω（往下收缩）和Θ（两端都要进行处理，类似前面两者）有类似的结论。
    
    - **对于两个连续执行部分组成的算法来说，其整体效率是由最大增长次数的部分决定的。如O(max{n^2,n})=O(n^2)**

### 2.3渐进符号的证明

- 方法1，利用定义证明抽象性质，比较两个函数的增长次数。

- 方法2：利用极限计算(还有各种求极限的公式)

  ```tex
  				{0,t(n)∈O(g(n))
  				{c,t(n)∈O(g(n)),t(n)∈Ω(g(n)),t(n)∈Θ(g(n))
  lim  t(n)/g(n)=	{∞，t(n)∈Ω(g(n))
  n->∞			{不存在
  ```

  <img src="..\图片\20210930165445.jpg" style="zoom:80%;" />

- 注意：常数时间效率的算法，当输入规模趋于∞时，运行时间也会趋于∞。

  ![](../图片\各级函数性能曲线.png)

- 渐进时间效率注意：

  - 对于规模较小的问题，决定算法工作效率的可能是算法的简单性而不是算法的执行时间。
  - 当比较两个算法的效率时，若两个算法是同阶的，必须进一步考察阶的常数因子才能辨别优劣。

### 2.4非递归算法的数学分析

- 分析步骤

  - 确定基本操作（如:比较操作、赋值操作）
  - 求基本操作的次数（如果无论什么样的输入细节，执行次数都一样，那么该算法没有必要考虑最优、最差和平均，因为都一样。反之则需要：比如在循环中某种条件下，符合情况，我们直接退出，这就需要考虑具体的输入细节。）

- 分析非递归算法效率的通用方案

  - 决定哪个（哪些）参数作为输入规模的度量。
  - 找出算法的基本操作（总是位于算法的最内层循环之中）
  - **检查基本操作的执行次数是否只依赖于输入规模。如果它还以来一些其它的特定，则最差、平均、最优效率需要分别研究**。
  - 建立基本操作执行次数的递推关系或求和表达式。

- 常用求和公式
  $$
  \sum^u_{i=l}=u-l+1
  \\
  \sum^n_{i=0}i=\sum^n_{i=1}i={n(n+1)\over2}
  \\
  \sum^u_{i=l}ca_i=c\sum^u_{i=l}a_i
  \\
  \sum^u_{i=l}(a_i+b_i)=\sum^u_{i=l}a_i+\sum^u_{i=l}b_i
  $$
  
- 非递归算法效率的方案并不是总能取得成功（这个意思不太懂）

  - 比如：循环变量无规律变化
  - 过于复杂而无法求解的求和表达式
  - 分析平均效率的固有难度。

### 2.5递归算法数学分析

- 一般递归分析是按照阶乘函数的形式进行分析

  - 阶乘函数F(n)=n!=1\*2\*3\*....*n.
    $$
    &n!=
    \begin{cases}
    1, &当n=0时\\
    n*(n-1)!, &当n\ge 1时
    \end{cases}
    \\
    &递归公式:F(n)=F(n-1)*n
    \\
    &0!=1
    $$

- 所以递归算法的分析关键时要找出递归公式

- 这个求解过程就很像数学中的数列求解，比如等比数列、等差数列、差比数列、迭代求解法、构造求解、等价替换等等

- 分析递归算法效率的通用方案

  - 分析一般步骤：
    - 决定哪个参数作为输入规模的度量
    - 找出算法的基本操作
    - 检查对于相同规模的不同输入，基本操作的执行次数是否不同。如果不同，则必须对最差、平均、最优效率单独研究。
      - 我是否可以理解为，如果在相同输入规模，执行次数会因为具体的输入细节而产生不同，这时就是一个相当于输入规模的以及细节的分段函数，因为限定了输入规模相同的情况下，所以我们能够将输入规模看作一个常量，那么就取决于输入细节，而输入细节取决于实际应用场景中各种输入细节的概率分布，所以算法的性能的总体性能状况应该在输入规模确定之后能够通过具体的函数或者概率分布图进行展示。
    - 对于算法基本擦欧总的执行次数、建立递推式及初始条件。
    - 解递推式，或者至少确定其解的增长次数。

- 递归的思路递归

  - 就是分治的思想
    - 将一个不能或者不好直接求解的“大问题”转化成一个或几个“小问题”来解决，再把这些“小问题”进一步分解成更小的问题，直到小问题能够直接解决为止。
    - 递归分解不是随意的分解，递归分解要保证“大问题”与小问题相似，即求解过程与环境都相似。并且有一个分解终点。从而使得问题可解。
  - 递归的执行过程：分解过程(顺向分解)和求值过程（逆向返回计算）。
    - 分解过程是量变过程，即原来的大问题在慢慢变小，但尚未解决。
    - 求值过程：遇到递归出口后，便发生了“质变”，即原递归问题便转化成直接问题。
  - 递归算法应该慎用，因为它们的简洁性可能会掩盖其低效率。

- 递归调用树分析方法

  - 如果一个递归算法会不止一次地调用它本身，可以构造递归调用树来进行分析（直观、简便）

  - 节点相当于递归调用，调用参数的值（或几个参数的值）标记节点，计算书中节点数。

    ![](..\图片\20211002103212.jpg)

  $$
  &A(n)=A(\lfloor n/2 \rfloor)+1(n>1)
  \\
  &对于这种求解式，可以在n=2^k下求解递推式，然后使用'平滑规则'进行调整。
  \\
  &平滑规则定理认为：在一个非常宽泛的假设下，无论n取何值，
  \\
  &它的增长次数与n=2^k时的增长次数是完全相同的。
  $$

- 斐波拉契数列（Fibonacci sequence），又称为黄金分割数列,兔子数列

  - 
    $$
    F(n)=F(n-1)+F(n-2)
    \\
    F(n)=
    \begin{cases}
    \ n, &n=0,1\\
    \ F(n-1)+F(n-2), &n\gt1
    \end{cases}
    $$
  
- 斐波拉契数列的精确解法
  
  - 使用母函数法：将原函数作为通式,再按照数列求解的方式进行求解即可
      $$
      a_n=a_{n-1}+a_{n-2}
      \\
      设母函数s(x)=\sum^\infty_{n=0}a_nx^n
      \\
      a_nx^n=xa_{n-1}x^{n-1}+x^2a_{n-2}x^{n-2}
      \\
      \sum^\infty_{n=2}a_nx^n=x\sum^\infty_{n=2}a_{n-1}x^{n-1}+x^2\sum^\infty_{n=2}a_{n-2}x^{n-2}
      \\
      s(x)-a_0-a_1x=x(s(x)-a_0)+x^2s(x)
      \\
      (1-x-x^2)s(x)=x
      \\
      最终解出F(n)=\frac 1{\sqrt 5}(α^n-β^n),其中α、β={1±\sqrt 5 \over 2}
      $$
  
- 斐波拉契数列的效率分析
  
  - 基本操作加法，输入规模为第几个斐波拉契数n
  
  - A(n)=A(n-1)+A(n-2)+1;原斐波拉契数列+1
  
  - 构造A(n)+1=B(n)；得到新的斐波拉契数列，B(0)=1,B(1)=1；
  
  - 因为已经解的原斐波拉契数列，所以建造新斐波拉契数列与原斐波拉契数列之间得到关系B(n)=F(n+1)，于是等价替换原解，得到新解=B(n)
  
    =F(n+1)的解。（这个关系自行验证）
    $$
      最终解出F(n+1)=\frac 1{\sqrt 5}(α^{n+1}-β^{n+1}),其中α、β={1±\sqrt 5 \over 2}
      \\
      所以效率类型
      A(n)=\frac 1{\sqrt 5}(α^{n+1}-β^{n+1})-1.
      \\
      A(n)\inΘ(Φ^n),Φ={1＋\sqrt 5 \over 2}
      \\如果n的二进制表示的位数b=\lfloor log_2n\rfloor+1
      \\来度量大小。效率类型变为：A(b)∈Θ(Φ^{2^b})
    $$
      ![](..\图片\20211002145630.jpg)
  
  - 该算法效率不高，为指数级增长效率类型。原因：因为使用递归的方式，不得不进行大量的重复计算相同的函数值。
  
  - 改良方式1
  
    ![](..\图片\20211002153058.jpg)
  
  - 我们还能够进行改进，将递归改变为非递归实现，存储所需前面的两个数，然后通过循环计算更新，得到最终的值。而这样做的算法效率直接从指数级升到线性级效率∈Θ(n)。
  
  - 从线性代数的角度处理
  
    ![](..\图片\20211002161315.jpg)
  
    - 这就是说要计算第n个数，就直接求这个矩阵的n阶，然后对应着F（n）位置的数就是要计算的数。

### 2.6算法的经验分析

- 通用方案
  - 了解实验的目的
  - 决定用来度量效率的量度和单位
  - 决定输入样本的特性（为了选取具有针对性或者比较合理的输入数据进行测试）
  - 为实验准备算法的程序
  - 生成输入样本
  - 对样本运行算法，记录实验结果
  - 分析获得实验数据（如散点图、概率分布图）



# 算法设计技术

- 代码位置 D:/ideaproject/algorithm

## 1.蛮力法

### 1.1定义

- 蛮力法是一种简单直接解决问题的方法，常常直接基于问题的描述和所涉及的概念定义。
- 蛮力法法常常最容易应用的方法
- “力”指的是计算机的计算能力，而不是人的智力
- 高效巧妙的算法很少来自蛮力法

### 1.2优缺点

- 应用范围广
- 不受实例规模的限制
- 当要解决的问题实例不多，设计更高效的算法的代价太大时可选用
- 对解决一些小规模的问题实例仍然有效
- 可作为衡量其他高效算法的参照物

### 1.3选择排序和冒泡排序

- 排序问题描述：给定一个可排序的n元序列（包含数字、字符的字母和字符串），将它按照非降序方式重新排列。

- 常用的8大排序算法：（选择排序、冒泡排序、插入排序、希尔排序、快速排序、归并排序、堆排序、基数排序）

  - 内部排序：使用内存

    - 插入排序

      - 直接插入排序（每来一个元素，就进行比较然后进行插入）
        - 前插
        - 后插
      - 希尔排序

    - 选择排序

      - 简单选择排序（遍历整个输入，选择最大值或者最小值放到固定位置）
      - 堆排序

    - 交换排序

      - 冒泡排序（遍历输入，相邻两两比较，按照大（小）规则进行交换）
      - 快速排序

    - 归并排序

    - 基数排序

      [1.10 基数排序 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/radix-sort.html)

  - 外部排序：内存和外存结合使用，就是内存不够用需要将中间结果存在磁盘上然后需要的时候进行读取。

- 两者相比较，选择排序更适合，是总体上更好的算法，以一种更加清晰地方式实现了蛮力算法。

- 冒泡排序

  - 原理：比较相邻的元素，将大的元素交换到右边的位置，重复多次后，最大元素就“沉淀”到列表的最后一个位置。第二遍将第二大元素沉下去，n-1遍后结束。

  - Java代码

    ```java
    class BubbleSort{
       public static void sort<T>(T[n]a){
           for(int i=0;i<=n-2;i++){
               for(int j=0;j<=n-2-i;j++){
                   if(a[j]<a[j+1]){
                       T temp =a[j];
                       a[j]=a[j+1];
                       a[j+1]=temp;
                   }
               }
           }
       } 
    }
    ```

    

  - 算法分析
    $$
    基本操作：比较操作a[j]<a[j+1]
    \\
    比较次数:
    \\
    C(n)=\sum^{n-2}_{i=0}\sum^{n-2-i}_{j=0}1=\frac {n(n-1)}2\inΘ(n^2)
    \\
    键交换操作次数：（取决于特定的输入）
    \\
    最差情况下，降序数组，这时键交换次数和键比较次数相同：
    \\
    S_{worst}(n)=C(n)=\frac{n(n-1)}2\in Θ（n^2）
    $$
    
  - 改进冒泡排序：如果对列表比较一遍之后没有交换元素的位置，那么这个表已经排好序了，算法就直接停止，没必要在进行多余的判断。（比如我们的输入其实就只有两个相邻的元素交换位置即可，那么进行一次循环扫描就行了没有必要再进行n-2次扫描）

    ```java
    //改进算法
    class BubbleSort{
       public static void sort<T>(T[n]a){
           for(int i=0;i<=n-2;i++){
               //每次扫描前我们设定表已经排好序了
               boolean flag=true;
               for(int j=0;j<=n-2-i;j++){
                   if(a[j]<a[j+1]){
                       T temp =a[j];
                       a[j]=a[j+1];
                       a[j+1]=temp;
                       //被动改变标识，一旦发生交换就将标识改变
                       flag=false;
                   }
               }
               //一次扫描完毕后判断是否排好序，是就返回
               if(flag){
                   return;
               }
           }
       } 
    }
    ```

    

  - 

  

- 选择排序

  - 原理：扫描整个待排序组，找出最小地元素，然后将最小元素与第一个元素交换位置，从第二个元素开始扫描，找出n-1个元素中地最小元素，将最小元素与第二个元素交换位置，如此类推，做n-1遍后排序结束。

  - Java源码

    ```java
    class SelectSort{
    public static void sort<T>(T[n]a){
    for (int i=0;i<=n-2;i++){
        int min=i;
        for(int j=i+1;j<=n-1;j++){
            if(a[min]>a[j]){
                min=j;
            }
        }
        T temp=a[min];
        a[min]=a[i];
        a[i]=temp;
    }
    }
    }
    ```

    

  - 性能分析
    $$
    基本操作：比较操作a[min]>a[j]
    \\
    C(n)=\sum^{n-2}_{i=0}\sum^{n-1}_{j=i}1=\frac {n(n-1)}2\in Θ(n^2)
    $$
    
  - 为什么会觉得选择排序是优化了的冒泡排序？
    - 因为两者都是将最小（大）的值最终放到固定位置，但是选择是遍历一遍然后将值拿出来，最后执行一次交换，但是冒泡是每次判断如果符合规则则会进行交换。其实两者的效率从级数上看都是∈Θ(n^2)，主要差异就是交换的概率高低，如果在一个逆序数组上正排序那么冒泡排序在交换上的花费必然是极大的。综上，所以会觉得选择优化 冒泡。
    - 实际上两者不是同一种排序思路，仅仅只是在同一种应用场景下的应用产生的比较造成的误感。
    - 而选择对应的堆排序，以及冒泡对应的快排才是同种思路的优化。

### 1.4顺序查找和蛮力字符串匹配

- 顺序查找问题

  - 描述：已知有n个元素的数组a[0……n-1]。给定元素K,要求找出一个下标i,使得a[i]=k.输出第一个值等于K的元素的位置，找不到返回-1。

    ```java
    class OrderFind{
        public static int search<T>(T[n]a,T k){
            /*注意使用for循环有一个潜在的判断就是i<n,但是我们往往会		   忽略，使用while的时候就不会忽略。所以在很细节的优化算            法的时候要考虑这点
            */
            for(int i=0;i<n;i++){
                if(a[i]==k){
                    return i;
                }
            }
            return -1;
        }
    }
    ```

    

  - 算法改进：如果把**查找键添加到列表的末尾**，那么查找就一定会成功所以不必在算法的每次循环时都检查是否到达了表末尾

    ```java
    class OrderFind{
        public static int search<T>(T[n]a,T k){
            int i=0;
            while(a[i]!=k){
                i++;
            }
            /*将n次判断变为最后一次判断和一个额外的空间，这就是空间换			时间
            */
            if(i<n){
                return i;
            }else{
                return -1;
            }
    }
    ```

  - 效率分析：在最差和平均情况下，改进算法只有轻微的提升，仍然是一个线性算法。

  - 再次改进：假如我们的给定的数组已知是有序的，可以对算法进一步改进，在列表中只要遇到一个大于或等于查找键的元素，查找就停止。（注意这里我们并不会再将元素添加到表尾了。）

  - 我觉得：存在新的问题，就是应用场景问题，应该如何解决

    - 场景1：我们的输入使得排序算法性能耗费级数高于或者是等于查找级数
    - 场景2：我们需要不改变原表的元素位置且最终需要返回元素的最终位置

- 蛮力字符串匹配问题：

  - 相关概念

    - 文本：给定的由n个字符组成的串
    - 模式：指定的由m（m≤n）个字符组成的串
    - 字符串匹配问题：从问厄本那中寻找匹配模式的子串，即是求出第一个匹配模式的子串再文本中的开始位置（子串最左元素的下标）。

  - 蛮力法解决思路：将模式对准文本的前m个字符从左至右进行比对，如果其中由一个字符不匹配，模式往右移动一位继续下一个m个字符的比对。(最后一捆字串匹配的其实位置是n-m；因为两者下标都是从0开始的)

  - java代码

    ```java 
    class StringMatching{
        public static int matching(String s,String pattern){
            for(int i=0;i<s.length-pattern.length;i++){
                int j=0;
                //对比字符串
                for(j=0;j<m;j++){
                    //如果由一个字符没有比对成功，就跳出比对
                    if(s[i+j]!=pattern[j]){
                        break;
                    } 
                }
                //判断是没有比对成功跳出循环还是比对完成
                //如果是比对成功就跳出循环，反之就移动模式
                if(j==m){
                    return i; 
                }
            }
            //如果一直没有找到就直接返回-1.
            return -1;
        }
    }
    ```

  - 算法效率分析

    - 输入规模取决于n(待匹配字符串长度),m(模式字符串长度)
    - 基本操作：比较操作s[i+j]!=pattern[j]
    - 执行次数：
      - 因为算法效率与具体的输入细节相关：**所以最差情况下，模式的长度为1，模式必须移动m(n-m+1)次，属于Θ(nm)**。最好情况下：就比较一次（可能是m<n也可能是m=n），比较次数取决于模式的长度m，所以属于Θ(m)，m，≤n。
      - 对于再自然语言文本中查找词的典型问题（或查找随机文本时），大多数移动都发生在很少几次比较之后，所以该算法的平均效率能够显示出线性效率Θ(n)。不会出现属于Θ(n^2)，最多可以说O(n^2)。

### 1.5最近对和凸包问题的蛮力算法

- 概述：最近对和凸包问题处理的是平面上的有限点集合，分别来自计算集合和运筹学。

- 最近对问题：
  - 在实际应用中，常利用点或者圆等简单集合对象代表显示世界中的实体。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的两家飞机，就是空间按中最接近的一对点。
  
  - 问题描述：在给定的n个点的集合中找出距离最近的两个点。即，给定平面S上n个点，找其中的一对点，使得在n（n-1）/2个点对中，该点对的距离最小。
    $$
    记(x,y)为点P的坐标值，\\
    则两个点P_i=(x_i,y_i)、P_j=(x_j,y_i)之间的距离公式为：\\
    d(P_i,P_j)=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}
    $$
    
  - 蛮力法解题思路：把所有的点两两组合，比较它们之间的距离即可以得到距离最小的一对。
  
  - Java代码
  
    ```java
    public class Point{
        public int x;
        public int y;
        @Overvide
        public String toString(){
            return "("+x+","+y+")";
        }
    }
    
    public class  RecentPoint{
        public static void bruceForceCloserstPoints(Point[n]poins){
            int p1;
            int p2;
            double dmin=∞;
            for(int i=0;i<n-1;i++){
                for(int j=i+1;j<n;j++){
                    double distance=distance(points[i],points[j])
                    if(dmin>distance){
                        dmin=distance
                        p1=i;
                        p2=j;
                    }
                }
            }
           System.out.println("最近点对为："+points[p1]+"与"+points[p2]);
           System.out.println("最近距离为："+dmin);
        }
        private double distance(Point p1,Point p2){
            return Math.sqrt((p1.x-p2.x)*(p1.x-p2.x)-(p1.y-p2.y)*(p1.y-p2.y));
        } 
    }
    ```
  
    
  
  - 效率分析
  
    - 基本操作：开方Math.sqrt((p1.x-p2.x)*(p1.x-p2.x)-(p1.y-p2.y)*(p1.y-p2.y))
    - 执行次数：n（n-1）/2∈Θ（n^2）
    - 由于计算机计算整数的平方根也大多是无理数，故在实际中，可用(p1.x-p2.x)*(p1.x-p2.x)-(p1.y-p2.y)*(p1.y-p2.y)代替((p1.x-p2.x)*(p1.x-p2.x)-(p1.y-p2.y)*(p1.y-p2.y))，从而避免求平方根，其实这样效率也小幅度提升，也算是用空间换时间。
    - 改进后：基本操作：求平方；执行次数：n（n-1）∈Θ（n^2）
  
- 凸包问题：

  - 凸集：设S是平面点集（有限的或无限的），如果S中任意两点为端点的线段都属于该集合，则称S是凸的。（凸集往往是一个二维的，在一定二维域内是连续的）
    - 特征1：非空的
    - 特征2:S集合中的任意两点连成的线段上的点都属于该集合。
    - 特征3：必然是无限的
    - 凸集的补集被称为反凸集
    
  - 凸包定义：一个点集S的凸包是**指包含S的最小凸集**。显然，如果S是凸的，则S的凸包就是S本身。（如果不是就要进行最小扩充。从凹到凸，从有限到无限）。**空集与一个点的集合也是凸集**
  
  - 凸包问题描述：给定一个n个点的点集S,求S的凸包。
  
  - 凸包的集合表示
    - S是两个点组成的集合，其凸包是两个点的线段
    - S是由三个不共线的点组成的集合，其凸包是以这三个点为顶点的三角形，S是由三个共线的点组成的集合，其凸包是以距离最远的两个点为端点的线段。
    - 注意：多边形指的是区域，形状内和边界上所有的点的集合。
  
  - 定理：任意包含n>2个点（**不共线的点**）的集合S的凸包，是以S中的某些点为顶点的凸多边形。特别地，如果所有点共线，则多边形退化为一条线段，它的两个端点仍在S中。
  
  - 极点：凸集的极点是指不会出现在集合中任何线段中间的点。凸多边形的极点是顶点。（例如：三角形的极点是其三个顶点，原型的极点是它圆周上所有点）
  
  - 通过上面的定理以及极点的定义，我们可以知道只要找到S集合中那些构成凸包的极点的点，然后连接起来就能解决凸包问题。
  
  - 凸包问题求解
  
    - 先要知道给定集合中哪些点是该集合的凸包极点。--*确定极点*
    - 其次，要知道***哪几对点***需要连接起来构成凸包的边界-- *这句话的意思真正的意思是说要将顶点连接成凸多边形需要将顶点连接成边，一条边需要的就是一个点对嘛或者你也可以确定它的连接顺序（这就是后面说的）一样的作用*。简言之，将极点按照顺时针方向或逆时针方向排列--就是按照这个排列顺序将这些极点连接起来。-- *确定极点连接顺序*
  
  - 蛮力法解决凸包问题
  
    - 思路：对于一个n个点集合中的两个点Pi和Pj，**当且仅当该集合中其他点都位于穿过着两点的直线的同一边时，他们的连线是该集合凸包边界的一部分**。对每一对点都做一遍检验之后，满足条件的线段构成了该凸包的边界。（通过这种方法不就能找到凸包的顶点了嘛）
  
    - 假如对于在边界上的点（顶点连线上的点）我们应该怎么进行条件判定和排除？
  
    - 具体解法：设点集大小为n，首先将其中的点两两配对，得到直线段；然后对每一条直线端检查其余的n-2个点的相对于该直线段的正负性，如果他们都有相同的正负性，那么这条直线段属于凸多边形的边，其端点是极点。
      $$
      设直线方程为：
      ax+by=c
      \\
      则\\
      使ax+by-c>0的点在直线上\\
      使ax+by-c<0的点在直线下\\
      \\线性规划的思想
      $$
      
  
      - 但是对于共线点的排除仍然没有解决吧？我们应该能够找到所有位于边界上的点，但是没有排除非顶点。
  
      - emmmmm,如果我们只是求出凸包有必要将边界上的点排除吗？没有必要，不影响解的正确性。但是应该存在效率问题，如果我们不能直接定位顶点，假设边界点很多，按理说这些点不应该再进入两两组合中的计算了，但是因为没有准确定位、没有进行边界排除，那么会进行大量的重复运算。
  
        <img src="..\图片\20211004151424.jpg" alt="d" style="zoom:50%;" />
  
      - 这个流程图有并查集的思想在里面。
  
    - Java代码
    
      ```java
      package convexhull;
      /*
       * 这个类用于定义集合点
       * */
      public class Point implements Comparable<Point>{
          private double abscissaD;//横坐标
          private double ordinateD;//纵坐标
      
          public Point(double abscissaD, double ordinateD) {
              this.abscissaD = abscissaD;
              this.ordinateD = ordinateD;
          }
      
          public double getAbscissaD() {
              return abscissaD;
          }
      
          public void setAbscissaD(double abscissaD) {
              this.abscissaD = abscissaD;
          }
      
          public double getOrdinateD() {
              return ordinateD;
          }
      
          public void setOrdinateD(double ordinateD) {
              this.ordinateD = ordinateD;
          }
      
      /*
      * 当型循环：当条件满足时执行循环体，不满足时退出。
      * 直到型循环：执行循环体直到条件不满足退出。
      * 因为使用是TreeSet，底层使用的红黑树，小的放左边，大的放右边，遍历的时候采用的是前序遍历。也就是：左根右。
      * 它比较的具体逻辑：遍历红黑树，将节点的key作为参数，如果返回小于0就说明待插入元素要比这个节点的key，反之大于。
      * 然后继续遍历子树，找到相等的节点就更新值并结束，如果到叶子节点都没有找到就结束循环，然后新建一个节点赋值，将其放在对应位置。
      * 如果等于节点的值就直接更新节点的值。
      *
      * */
          @Override
          public int compareTo(Point o) {
              //横坐标小的先输出
              if(this.abscissaD<o.abscissaD){
                  return -1;
              }else if (this.abscissaD>o.abscissaD){
                  return 1;
              }else{
                  //如果横坐标相等就比较纵坐标
                  //纵坐标小的先输出
                  if(this.ordinateD<o.ordinateD){
                      return -1;
                  }else if(this.ordinateD>o.ordinateD){
                      return 1;
                  }else{
                      return 0;
                  }
              }
          }
      
          @Override
          public String toString() {
              return "("+this.abscissaD+","+this.ordinateD+")";
          }
      }
      
      ```
    
      
      
      ```java
      package convexhull.bruteforce;
      
      import convexhull.Point;
      
      import java.util.Iterator;
      import java.util.TreeSet;
      
      /*
       * 使用蛮力法解决凸包问题
       * 输入：一个点集
       * 输出：凸包极点连接顺序
       * */
      public class BruteForce {
          public TreeSet<Point> convexHullAlgorithm(TreeSet<Point> pointSet) throws Exception {
              //如果为空就抛出异常
              if (pointSet == null) {
                  throw new Exception(pointSet + "is null");
              }
              //如果点数目小于3,是就直接返回,因为我们已经制定了排序规则
              if (pointSet.size() < 3) {
                  return pointSet;
              }
              //先找出凸多边形边上的点
              //将集合转换为数组
              Point[] points =toArray(pointSet);
              TreeSet<Point>result=new TreeSet<Point>();
              //外层执行n-1次循环
              for(int i=0;i<points.length-1;i++){
                  //内层循环从外层的下一个元素开始
                  for (int j=i+1;j<points.length;j++){
                      //计算出两点所在直线
                      StraightLine straightLine=calcunateLine(points[i],points[j]);
                      //验证其他点的正负性
                      int  flag=0;//记录正负一致性
                      int l=0;
                      for(;l<points.length;l++){
                          if(l!=i&&l!=j){
                             double t= (float) (straightLine.k*points[l].getAbscissaD()+straightLine.b-points[l].getOrdinateD());
                             if((flag>0&&t<0)||(flag<0&&t>0)){
                                 break;
                             }else if(t>0){
                                 flag=1;
                             }else if (t<0){
                                 flag=-1;
                             }
                          }
                      }
                      if (l==points.length){
                          result.add(points[i]);
                          result.add(points[j]);
                      }
                  }
              }
              //从找出的点中筛选出极点然后返回
              collinear(result);
              return result;
      
          }
      
          //将集合转换为数组
          private Point[] toArray(TreeSet<Point> pointTreeSet){
              Point[] points=new Point[pointTreeSet.size()];
              Iterator<Point> iterator=pointTreeSet.iterator();
              int index=0;
              while (iterator.hasNext()){
                  points[index++]=iterator.next();
              }
              return points;
          }
      
          //计算两点所在直线
          private StraightLine calcunateLine(Point point1,Point point2){
              double k=(point1.getOrdinateD()-point2.getOrdinateD())/(point1.getAbscissaD()-point2.getAbscissaD());
              double b=point1.getOrdinateD()-(k*point1.getAbscissaD());
              return new StraightLine(k,b);
          }
      
          //使用向量法删除共线的点
          private void collinear(TreeSet<Point> pointTreeSet) {
              Point[] points=toArray(pointTreeSet);
              //从第一个节点开始到倒数第二个节点结束
              for (int i=0;i<points.length-2;i++){
                  //从第i+1节点开始到倒数一个节点结束
                  for(int j=i+1;j<points.length-1;j++){
                      double x1=points[i].getAbscissaD()-points[j].getAbscissaD();
                      double y1=points[i].getOrdinateD()-points[j].getOrdinateD();
                      double x2=points[j].getAbscissaD()-points[j+1].getAbscissaD();
                      double y2=points[j].getOrdinateD()-points[j+1].getOrdinateD();
                      if((x1*y2)==(y1*x2)){
                          //如果三点共线就将中间点删除，因为我们事先已经排好序了
                          pointTreeSet.remove(points[j]);
                      }
                  }
              }
          }
      
          //私有内部类用于存储直线
          private class StraightLine{
              double k;
              double b;
      
              public StraightLine(double k, double b) {
                  this.k = k;
                  this.b = b;
              }
          }
      
      
      }
      ```

### 1.6穷举查找

- 概述：许多重要的问题，要求在一个复杂度随实例规模指数增长（或更快）的域中，查找一个具有特定属性的元素，使得某些期望的特性最优化（最大化或最小化），比如路径长度最优、分配成本最小、排列、组合或是给定集合的子集等。
- 穷举查找是一种简单的蛮力法，它要求生成所有可能的可行解，再从中选择最优解。
- 在实现时常常需要用算法来生成某些组合对象
- 旅行商问题（tsp）
  - 描述：给定n个城市相互之间的距离，求一条能走遍n个城市的最短路径，使我们能从任一城市开始，访问每个城市只一次后回到起点。
  - 等价问题：哈密尔顿回路问题，有一个n个相邻点的序列，其中n个顶点互补相同
  - 这些问题往往都涉及到排列组合，所以往往算法的时间效率都是指数阶乘级别。
  - 背包问题、分配问题等等

### 1.7深度优先遍历

- 可以从任何顶点开始访问图的顶点，每次迭代时，处理与当前顶点相邻的未访问顶点（长按照字母顺序来选择）。持续这个过程，直到遇见一个所有相邻顶点都已经被访问的点，回到上一个节点。当所有节点都被访问完（即是起始顶点相邻点访问完时，算法停止）

- 如果还存在有未访问的顶点，找到它，重复算法。

- 特点：

  - DFS用树向边来到达原先未访问的顶点；仅考虑树向边，得到的是森林。回边把遍历中已访问顶点的非直接前驱和顶点连接起来，在森林中，把顶点和顶点的非父母祖先连接起来。

- 应用：连通性、无环性、关节点（从图中溢出一个节点和所有它附带的边之后，图被分为若干个不相交的部分，这样的节点称为关节点,在图论中也被称为割点。其实就是树枝的交接点）

  - 连通性：一个顶点到其他任何一个顶点都有路径。一次遍历之后如果还有顶点没有被访问，那么就不具备连通性。（另外的说法：遍历后得到的时一颗树就是连通，如果是森林就是不连通的）

  - 无环性：如果在遍历过程中，访问某个顶点时，发现相邻的顶点已经被访问过了，则存在环。（也就是存在回边，就是有环。）

  - 关节点：就是去除这个点能将这个图的顶点集划分为两个在边的关系上完全无交集的集合。这样的点往往是树枝节点，但是树枝节点不一定是关节点，因为还可能存在回边。

    （为什么深度优先遍历能容易的找到关节点：**主要原因就是它能容易的将顶点进行分支**。深度遍历必然会找到当前连通部分的节点的最长的路径，其他的分支必然是建立在这条路径之上的，如果在分支上的点不存在与其他分支上的点形成回边，那么将两分支相连的两个点去除任意一个，各分支上的点根据点之间的关系都能形成两棵独立的树或图。）

  - ![](..\图片\20211019194743.jpg)
  - ![](..\图片\20211019195706.jpg)

-  深度优先搜索的效率与图的表示有关：（分析思路，遍历就是要访问所有的顶点，所以输入规模是顶点数）

  －　用邻接矩阵表示图，遍历的效率为Θ（｜顶点数｜＾２）

  - 邻接矩阵的规模是顶点数的平方。而遍历的形式是，要逐一验证每个下标的值，是否有关系是不确定的，满足条件才会访问，否则不会。所以整个邻接矩阵都会访问。故效率。

  －　用邻接表表示，遍历效率为Θ（｜顶点数｜＋｜边数｜）

  - 邻接表只记录相邻的节点，对于无向图虽然可能存在节点的冗余。但是顶点数组一定会访问，而链表部分的数目，基本可以使用边来进行表示。对于全连通无向图链表部分的数目就是边数，而全连通无向图就是边数的二倍，当然还有非连通的，但是无非就是在边的基础上（乘上一个常数因子、加减一个常数因子罢了），去除常量因子，其实边为输入规模的同等级效率。

- [(4条消息) 图 深度优先遍历 广度优先遍历 非递归遍历 图解算法过程_冰冻火山-CSDN博客](https://blog.csdn.net/collonn/article/details/17923851)

- 使用栈来跟踪深度优先查找的操作（第一次访问一个顶点时，该顶点入栈；当他所有相邻点访问完时出栈）

  ```java
  //使用邻接矩阵存储图
  public class AdjacencyMatrix {
      private int[][] martix;
  
      public AdjacencyMatrix(int[][] martix) {
          this.martix = martix;
      }
  
      public int[][] getMartix() {
          return martix;
      }
  
      public void setMartix(int[][] martix) {
          this.martix = martix;
      }
  }
  
  //递归算法
  public class RecursionD {
      private AdjacencyMatrix adjacencyMatrix;
      private int[] state;
  
      public RecursionD(AdjacencyMatrix adjacencyMatrix) {
          this.adjacencyMatrix = adjacencyMatrix;
          this.state = new int[adjacencyMatrix.getMartix().length];
      }
  
      public void DFS() {
          for (int i = 0; i < state.length; i++) {
              if (state[i] == 0) {
                  DFSR(i);
              }
          }
      }
  
      private void DFSR(int i) {
          if(state[i]==0){
              System.out.println(i);
              state[i]=1;
              for(int j=0;j<state.length;j++) {
                  if (adjacencyMatrix.getMartix()[i][j]==1&&state[j]==0){
                      DFSR(j);
                  }
              }
          }
      }
  }
  
  
  //非递归算法，使用栈进行当前访问节点状态记录
  public class NonRecursionD {
      private AdjacencyMatrix adjacencyMatrix;
      private int[] state;
  
      public NonRecursionD(AdjacencyMatrix adjacencyMatrix) {
          this.adjacencyMatrix = adjacencyMatrix;
          this.state = new int[adjacencyMatrix.getMartix().length];
      }
  
      public void DFS() {
          for (int i = 0; i < state.length; i++) {
              if (state[i] == 0) {
                  DFSNR(i);
              }
          }
      }
  
      private void DFSNR(int i) {
          ArrayList<Integer> stack = new ArrayList<Integer>();
          stack.add(i);
          while (!stack.isEmpty()) {
              int top = stack.get(stack.size() - 1);
              if (state[top] == 0) {
                  System.out.println(top);
                  state[top] = 1;
              }
              boolean isOver = true;
              for (int j = 0; j < state.length; j++) {
                  if (adjacencyMatrix.getMartix()[i][j] == 1 && state[j] == 0) {
                      stack.add(j);
                      isOver = false;
                  }
              }
              if (isOver) {
                  stack.remove(stack.size() - 1);
              }
          }
      }
  }
  ```
  
  
  
  

### 1.8广度优先遍历

- 找到一个未被访问的节点，然后循环访问它所有相邻的节点，直到所有节点访问完成。使用队列进行节点存储辅助遍历。

- 1、从图的某个节点出发，访问这个节点

- 2、再访问这个点相邻且未被访问的点，直到相邻元素访问完。

- 3、从相邻元素中选取一个重复2.直至所有节点访问完

- 根据BFS访问特点，我们将BFS访问的边称作＊BFS的树向边＊，它是一种通向原先未访问顶点的边，交叉边把顶点和那些已访问顶点（同层或相邻层）相连。

  - ![](..\图片\20211019203608.jpg)

- 广度优先的应用：验证树、图的连通性、无环性、最少边路径

  - 连通性：一个顶点到其他任何一个顶点都有路径。一次遍历之后如果还有顶点没有被访问，那么就不具备连通性。（另外的说法：遍历后得到的时一颗树就是连通，如果是森林就是不连通的）
  - 无环性：如果在遍历过程中，访问某个顶点时，发现相邻的顶点已经被访问过了，则存在环。（也就是存在交叉边，就是有环。）
  - **最少边路径：如果一个顶点到另一个顶点之间有路径，那么边最少的路径是哪一条**。那么我们就可以直接从指出的顶点开始广度优先遍历。将遍历出来的路径构造成一棵树，那么最短边路径就一目了然。（且边数就是目的顶点所在新树的层数+1）
    - 原因解释，因为从一个点开始广度优先遍历，那么必然是到这个点边数相同的处于同一层，且同等级别被访问。更长的边处于树的更深层。而深度优先遍历为什么不行呢？深度优先遍历没有这个规律，它是优先要访问到最多的节点，且是随机的选取相邻节点，那么很可能你访问到目标节点的时候就是最深的时候，而当最短路径却是在再次访问的时候，但是已经被访问了，那么这条边只能作为回边，要找最短边，相当于没有做任何操作，完全没有意义。

- 广度优先搜索的效率与图的表示有关：（分析同深度优先遍历）

  －　用邻接矩阵表示图，遍历的效率为Θ（｜顶点数｜＾２）

  －　用邻接表表示，遍历效率为Θ（｜顶点数｜＋｜边数｜）

  ```java
  //使用邻接表进行图存储
  public class AdjacencyList {
      private Node[] adjacencyList;
  
      public AdjacencyList() {
          this(Integer.MAX_VALUE);
      }
  
      public AdjacencyList(int length) {
          adjacencyList = new Node[length];
      }
  
      public AdjacencyList(Node[] adjacencyList) {
          this.adjacencyList = adjacencyList;
      }
  
      public Node[] getAdjacencyList() {
          return adjacencyList;
      }
  
      public void setAdjacencyList(Node[] adjacencyList) {
          this.adjacencyList = adjacencyList;
      }
  
      public static class Node {
          private int currentNode;
          private Node nextNode;
  
          public Node() {
          }
  
          public Node(int currentNode, Node nextNode) {
              this.currentNode = currentNode;
              this.nextNode = nextNode;
          }
  
          public int getCurrentNode() {
              return currentNode;
          }
  
          public void setCurrentNode(int currentNode) {
              this.currentNode = currentNode;
          }
  
          public Node getNextNode() {
              return nextNode;
          }
  
          public void setNextNode(Node nextNode) {
              this.nextNode = nextNode;
          }
      }
  }
  
  //使用队列进行节点存储，循环直至队列中没有节点，如果是非全联通图就扫描状态表找到一个未访问点再调用上诉方法。直至所有节点访问完
  public class NonRecursion {
      private AdjacencyList adjacencyList;
      private int[] nodeState;//记录节点访问状态
  
      public NonRecursion(AdjacencyList adjacencyList) {
          this.adjacencyList = adjacencyList;
          nodeState = new int[adjacencyList.getAdjacencyList().length];
      }
  
      public AdjacencyList getAdjacencyList() {
          return adjacencyList;
      }
  
      public void setAdjacencyList(AdjacencyList adjacencyList) {
          this.adjacencyList = adjacencyList;
      }
  
      public void BFS() {
          for (int i = 0; i < nodeState.length; i++) {
              if (nodeState[i] == 0) {
                  BFSNR(i);
              }
          }
      }
  
      private void BFSNR(int i) {
          ArrayList<AdjacencyList.Node> nodeQuene = new ArrayList<AdjacencyList.Node>();
          nodeQuene.add(adjacencyList.getAdjacencyList()[i]);
          while (!nodeQuene.isEmpty()) {
              AdjacencyList.Node tNode = nodeQuene.get(0);
              if (nodeState[tNode.getCurrentNode()] == 0) {
                  System.out.println(tNode.getCurrentNode());
                  nodeState[tNode.getCurrentNode()]=1;
                  AdjacencyList.Node nextNode = tNode.getNextNode();
                  nodeQuene.remove(0);
                  while (nextNode != null&&nodeState[nextNode.getCurrentNode()]==0) {
                      nodeQuene.add(nextNode);
                      nextNode = nextNode.getNextNode();
                  }
              }
          }
      }
  }
  ```




##2.减治法

- 概述：（比如要求吃完1000个大饼，你可以少少的吃，每天吃一个（或者吃一半、三分之一、剩余的一半等等），那么每天就离目标就更近，第二天遗留的问题就更少。你也可以将这些饼分给几十个人吃（他们也可以选择具体将这些饼的吃法），甚至分的个数不同，但是要所有人将各自的吃了的饼数，都向你汇报，这样你整合计数，直到计数为为1000个，那么这个问题才算解决。前者是减治法、后者是分治法）

  - 思想：减治法是利用一个问题给定实例的解和同样问题较小实例的解之间的某种关系。（也就是大规模问题与小规模问题是相同问题，只是输入规模不同而已，但是**大小规模之间还存在一定的固有关系**，所以解决小规模问题也就解决了大规模问题）
  - 减治技术利用了一个问题给定实例的解和同样问题较小实例的解之间的某种关系。一旦建立了这种关系，就可以从顶至下递归的来用该关系，也可以从底至上非递归的来运用该关系
  - 一般来说减去的一个常数因子是2（即将原问题规模分为2），**其实减常因子的减治法可以看做是分治的变种，只不过它只对划分子规模后的一个部分求解**。
  - 一旦建立了这种关系，可自顶向下或自底向上来运用该关系
  - 自顶向下会导致递归算法，但是非递归实现较好。
  - 自底向上往往是迭代实现的，从求解问题的一个较小实例开始，称为增量法（Incremental Approach）。

- 减治法三个变形：

  - 减常量：每次迭代总是从实例规模中减去一个相同的常量。通常是1，如n->n-1。
    $$
    例如，f(n)=a^n,可用递归定义n=0时，f(0)=1;
    \\
    n>0时，f(n)=f(n-1)*a来"自顶向下"计算；
    \\
    也可以"自底向上"把a自乘n-1次（蛮力法）
    $$

  - 减常量因子（如1/2）：每次迭代总是从实例的规模中减去一个相同的常数因子。通常是减半，即n->n/2。
    $$
    例如，求a^n的值，\\
    &a^n=
    \begin{cases}
    (a^{n/2})^2, &当n为正偶数时\\
    (a{(n-1)/2}^2)*a, &当n是正奇数时\\
    1,&n=0时
    \end{cases}
    $$
    递归计算，根据所做乘法次数来度量算法效率，为Θ(logn),因为每次迭代时，问题的规模减半。

  - 减可变规模：每次迭代规模减小的模式都是不同的。例如：欧几里得算法，gcd(m,n)=gcd(n,m mod n)。

### 2.1插入排序

- 插入排序的过程类似玩牌时整理手中纸牌的过程。

- 基本思想：每一步将一个待排序的对象按照其关键字的大小，插到前面已经排好序的序列中的适当位置，直到全部对象插入完毕为止。

- 常用的插入排序：直接插入排序（插入排序）、希尔排序、折半插入排序（就是插入时使用折半查找确定待插入位置）和链表插入排序（就是使用链表结构进行元素存储），他们划分的依据是在排好序的序列中寻找插入位置所使用方法的不同。

  ```java
  //普通直接插入算法
  //除了这种前插入思路外，还可以直接使用后插入，从检查处元素前一个开始检查，如果大于待插入元素就将其后移，直到找到一个小于或者等于待插入元素为止，将待插入元素放入空位
  public class InsertionSort extends Sorted{
      private Comparator comparator;
  
      public InsertionSort() {
          comparator=null;
      }
  
      public InsertionSort(Comparator comparator) {
          this.comparator = comparator;
      }
  
      @Override
      public <T> void sorted(T[] array) {
          for (int i = 1; i < array.length; i++) {
              T temp=array[i];
              boolean isBreak=true;
              for(int j=0;j<i;j++){
                  if(comparator!=null){
                      isBreak=toExchange(comparator.compare(temp,array[j]),array,temp,j,i-1);
                  }else if (temp instanceof Comparable){
                      isBreak=toExchange(((Comparable)temp).compareTo(array[j]),array,temp,j,i-1);
                  }else{
                      try {
                          throw new Exception("目标类没有实现Comparble接口-未指定Comparator比较器");
                      } catch (Exception e) {
                          e.printStackTrace();
                      }
                  }
                  if(isBreak){
                      break;
                  }
  
              }
          }
  
      }
  
      private boolean  toExchange(int compareResult,Object[]array,Object temp,int sIndex,int eIndex){
              if(compareResult<0){
                  for(int i=eIndex;i>=sIndex;i--){
                      array[i+1]=array[i];
                  }
                  array[sIndex]=temp;
                  return true;
              }
              return false;
      }
  }
  ```

- 性能分析：

  - 基本操作：键值比较；

  - 比较次数：最差情况：数组逆序，每次插入需要比较已插入的所有元素，此时，第i次插入比较i个元素，故
    $$
    C_{worst}(n)=\sum^{n-1}_{i=1}i={n(n-1)\over2}\in Θ(n^2)
    $$
    此时与选择排序的键值比较次数完全一致。

  - 最好情形：输入数组已按照顺序排列，每次迭代中，比较操作只执行一次，。于是键值比较次数为
    $$
    C_{best}(n)=\sum^{n-1}_{i=1}1=n-1\inΘ(n)
    $$
    
  - 插入排序的平均比较次数是降序数组的一半。
    $$
    C_{avg}(n)≈{n^2\over4}\inΘ（n^2）
    $$
    

### 2.2拓扑排序

- 描述：对给定的无环有向图，要求按照某种顺序列出它的顶点序列，使图的每一条边的起点总在结束顶点之前。（就是说后驱节点一定要在先驱节点后访问。）
- 例子：比如要修某些课程必须要先修某些其他的课程。
- 方法1：应用DFS的出栈次序倒序得到拓扑排序。（注意这是无环有向图）
  - 先准备两个栈，栈1，栈2

  - 随意找一个点入栈1，开始深度优先遍历。

  - 栈1顶点出栈，访问这个点相邻点（也就是后驱点），如果这个点没有未访问的相邻的点，就将这个点出栈，放于栈2中。然后继续取栈顶元素。直到栈1为空，这次深度优先遍历完成，如果还存在未访问的点就扫描访问情况，然后重复过程。

  - 最后将栈2元素全部出栈即是拓扑排序结果。

  - ![](..\图片\20211020212657.jpg)

  - ```java
    public class DFST {
        private TopologocalMap topologocalMap;
        private int[] state;
        //存储顶点入栈顺序
        private ArrayList<Integer> stack1;
        //存储顶点出栈顺序
        private ArrayList<Integer> stack2;
    
        public DFST(TopologocalMap topologocalMap) {
            this.topologocalMap = topologocalMap;
            state = new int[topologocalMap.getMatrix().length];
            //存储顶点入栈顺序
            stack1 = new ArrayList<Integer>(topologocalMap.getMatrix().length);
            //存储顶点出栈顺序
            stack2 = new ArrayList<Integer>(topologocalMap.getMatrix().length);
        }
    
        public ArrayList<Integer> topologicalSorted() {
            //先随意找到一个顶点进行深度优先访问
            for (int i = 0; i < state.length; i++) {
                if (state[i] == 0) {
                    DFS(i);
                }
            }
            //返回栈2
            return stack2;
        }
    
        //深度优先遍历
        private void DFS(int i) {
            //先加入栈1
            stack1.add(i);
            //修改其访问状态
            state[i] = 1;
            //当栈中所有元素出栈就停止
            while (stack1.size() > 0) {
                //取出栈顶元素
                int temp = stack1.get(stack1.size() - 1);
                //如果这个元素没有未访问的出度元素了就进行出栈然后加入栈2中，否则就访问未访问的，然后将其入栈1
                int j = 0;
                for (; j < state.length; j++) {
                    //这里没有加上temp！=j的判断，因为我们的初始条件就是无环有向图，所以不应该存在自环现象
                    if (state[j] == 0 && topologocalMap.getMatrix()[temp][j] == 1) {
                        //将这个顶点加入栈，修改其状态，然后直接退出循环
                        stack1.add(j);
                        state[j] = 1;
                        break;
                    }
                }
                //如果这个元素没有未访问的出度元素了就进行出栈然后加入栈2中
                if (j >= state.length) {
                    stack2.add((Integer) temp);
                    stack1.remove((Integer)temp);
                }
            }
        }
    }
    ```

  - 
- 方法2：减治法，源删除算法，每次选择没有输入的点。
  - 就是先找到一个没有入度的顶点，输出它，然后删除这个点（至于使用何种方法都行，比如将它在邻接矩阵中所有的出度边置为0）
  
  - 接着再找一个没有入度的点，又删除。重复过程直到所有点被删除/访问。（可以使用队列来辅助，感觉还是有点广度遍历的味道。）
  
  - ![](..\图片\20211020213900.jpg)
  
    ```java
    public class SourceDelete {
        private TopologocalMap topologocalMap;
        private int[] state;
        //用于存储拓扑序列
        private ArrayList<Integer>quene;
    
        public SourceDelete(TopologocalMap topologocalMap) {
            this.topologocalMap = topologocalMap;
            state=new int[topologocalMap.getMatrix().length];
            quene=new ArrayList<Integer>(state.length);
        }
        //我们的删除思路是将访问状态置为已经访问了，相当于已经删除它了。
        //仅仅修改访问状态是不够的，因为我们还需要确定访问源点，还是需要扫描整列状态确定访问状态。
        //所有还需要将其有关系的位置置为0即是将有关系变为没有关系，
        public ArrayList<Integer> topologicalSequeceM1(){
            for (int i=0;i<state.length;i++) {
                //寻找没有出度的元素
                int element=nonDegree();
                //如果存在这样的顶点，我们就将它加入队列。如果不存在就退出了，因为所有的顶点都被访问完了
                //这个条件其实和这个循环重复了
                if(element>-1){
                    quene.add(element);
                    state[element]=1;
                    //加入队列后，我们就需要将这个点删除
                    deleteElement(element);
                }
            }
            return quene;
        }
    
        //寻找没有出度的元素
        private int nonDegree(){
            for (int i = 0; i < state.length; i++) {
                //如果这个元素没有被访问，我们再进入循环看它有没有入度
                if(state[i]==0) {
                    int j = 0;
                    for (; j < state.length; j++) {
                        if(topologocalMap.getMatrix()[j][i]==1){
                            break;
                        }
                    }
                    //如果有入度我们就将这个元素的下标进行返回
                    if(j>=state.length){
                        return i;
                    }
                }
            }
            //如果扫描完整个表我们都没有找到需要的点，就直接返回-1
            return -1;
        }
        //删除源点
        private void deleteElement(int element){
            for (int j = 0; j < state.length; j++) {
                topologocalMap.getMatrix()[element][j]=0;
            }
        }
    }
    ```
  
    

### 2.3生成组合对象的算法

- 主要针对问题：组合对象问题。如**排列、组合、求给定集合的子集**（像蛮力法解决旅行商、背包问题、分配问题等，都需要先将目标所有的组合生成，然后计算需要的值，再比较求出最终的需求解。）

#### 2.3.1生成排列

- 概述：排列问题指的是对于给定的多个元素求其中各种可能的序列。（排列是队列顺序问题，组合是集合无序问题）
- 典型问题：考虑1到n之间的整数的排列问题。
- 典型生成方法：插入法、Johnson-Trotter法、字典顺序法

##### 2.3.1.1插入法

- 思路：就是在小规模的已存在的序列中的间隙插入符合需求的元素得到序列。这也是一种减治法的减常量的思想，你可以自顶向下进行分解，也可以自底向上进行增量。

- 例：求n=3（元素有1、2、3）的全排列（将大规模减小，然后逆向插入元素）
  - 在n=2（元素有1、2）的排列中插入3
  - 在n=1（元素有1）的排列中插入2
  - n=1的序列：为1，有两个空可以进行插入2。
  - 得到n=2的序列：12、21。这两个序列有3个位置可插入。
  - 123、132、312、321、231、213
  - 得到n=3的序列：123、132、312、213、231、321
  
- 优点：能够满足**最小变化要求**--仅仅交换直接前驱中的两个元素就能得到任何一个新的排列，即下一个序列与上一个序列仅仅交换的两个元素的位置。（也就是说将待插入元素插入任意一个位置之后只需要插入元素与任意一个序列中的元素进行交换位置就能得到一个新的序列。）（那么通过这个特征我们就可以有另一种算法的实现方式，就不采用每次寻找插入的位置的方式，而是选择一个插入位置（一般就起始位置，下标0）之后，插入元素n，得到序列temp，然后逐步选取交换位置i，复制temp，新序列插入元素n进行与位置i交换，直到所有的位置都交换一遍。---------这个实现思路优点：简便、不用再拷贝的时候每次都去判断插入位置，直接最终进行交换即可。）

  ```java
  /*
  * 该类用于测试插入法在数的全排列上的应用
  * 因为会进行复制操作
  * */
  public class ArrangementInsertion {
      //用于存储所有的排列序列
      private ArrayList<ArrayList<Integer>> squences;
  
      public ArrangementInsertion() {
          //初始化就是1的全排列
          squences=new ArrayList<ArrayList<Integer>>();
          ArrayList<Integer>arrayList=new ArrayList<Integer>();
          arrayList.add(1);
          squences.add(arrayList);
      }
  
      public ArrayList<ArrayList<Integer>> wholeArrangement(int num){
          //判定元素个数为0、1的状况
          if(num==0){
              return null;
          }else if(num==1){
              return squences;
          }else {
              //使用减治法思想自底向上进行排列增量,直接从2开始
              for (int i = 2; i <= num; i++) {
                  insertArrangement(i);
              }
              return squences;
          }
      }
  
      //将元素插入已经存在的序列中
      private void insertArrangement(int element){
          //获取插入位置数目,前面排列的元素数目就是element-1,空位数目就在这个基础上加一所以是element。一刀两断懂吧。
          int locationNum=element;
          int oldSize=squences.size();
          //扫描整个序列数组
          for (int i=0;i<oldSize;i++){
              //选取位置进行插入，因为我们使用是队列存储，每次将对手元素取出，新元素添加到队尾。所以，每次取下标0就行了。
              ArrayList<Integer> temp=squences.get(0);
              squences.remove(0);
              //插入一个元素，相当于总数就是element,而这个空位就是在这些位置上选一个即可，我们直接就下标而言，所以从0开始，到element-1结束。
              for (int j=0;j<locationNum;j++){
                  //新建一个序列准备插入
                  ArrayList<Integer> newList = new ArrayList<Integer>();
                  //用于标识当前复制的位置。
                  for (int flag=0;flag<locationNum-1;flag++) {
                      //如果当前位置正是待插入位置，就插入.然后将剩余部分全部拷贝
                      if (flag == j) {
                          newList.add(element);
                      }
                      //插入后，将剩余部分复制到新数组中
                      newList.add(temp.get(flag));
                  }
                  //虽然最后一次的时候,上面的循环会将整个temp复制，但是最后一次插入没有处理所以需要插入特殊处理，只需要将element插入即可
                  if(j==locationNum-1){//这里使用j作为判定条件，因为j是标识在第几个位置插入，如果是使用flag的话，每次循环结束flag的值必然是locationNum-1
                      newList.add(element);
                  }
                  squences.add(newList);
              }
          }
      }
  }
  ```

  

  ```java
  //使用最少交换次数特征的算法
      private void minExchange(int element) {
          //前面基本每啥区别，主要是交换,因为以下我们晓得这些数值之间的关系，所以就不使用size来定位大小了。
          int locationNum = element;
          int oldSize = squences.size();
          for (int i = 0; i < oldSize; i++) {
              ArrayList<Integer> temp = squences.get(0);
              squences.remove(0);
              //我们直接使用最后一个位置作为首次插入,并且加入队列
              temp.add(element);
              squences.add(temp);
              //开始选取交换位置
              for (int j = 0; j < locationNum - 1; j++) {
                  //复制temp,直接调用clone函数
                  ArrayList<Integer> integerArrayList = (ArrayList<Integer>) temp.clone();
                  //交换元素位置,就不抽出一个函数了。
                  Integer swap = integerArrayList.get(j);
                  integerArrayList.set(j, element);
                  integerArrayList.set(locationNum - 1, swap);
                  //再将其加入队列
                  squences.add(integerArrayList);
              }
          }
  
      }
  ```
  
  

##### 2.3.1.2Johnson-Trotter法

- 概述：有些算法不需要直到规模n-1的排列就可以直接得到规模n的排列结果，如Johnson-Trotter算法，且满足最小变换要求。

- 思路方法：（本质的理解：就是使用插入法--在n-1的序列中插入n生成序列。因为n始终就是最大的值，它一旦开始移动必然就是从当前位置移动到另一个边界。而起始位置n处于边界，所以n一旦开始移动就是从一个边界移动到另一个边界。而每次非n元素进行移动，就会调转n的方向，再次让它进行移动，所以其他非n元素一旦产生一个新序列就会让他进行移动，（故等价于在n-1的序列中插入n）。如果实在不好理解就从n=1开始逐增理解。
  
- 具体伪代码：
  
  - while(存在一个移动元素) do
  - 求最大的移动元素K
  - 把K和它箭头指向的相邻元素互换
  - 调转所有大于K的元素的方向
  - 将新排列添加到序列组中
  
  - 下面这张图的说法是错误的,仅仅只是用来感觉移动的感觉
  
  - ![](..\图片\20211022124715.jpg)
  
- 思想证明：Johnson-Trotter算法实际上就是向 n-1 个数的排列中插入第n个数……

  对于 n 个数的全排列，最大的那个数每次都会在剩下 n-1个数不变的情况下从左到右或者从右到左逐位移动**直到边界**，然后剩下 n-1 个数中的一个进行一次移动后最大数继续移动。

  显然当我们对最大数忽略不计时，剩下 n-1 个数的移动也就相当于 n-1 个数的全排列，这表明如果Johnson-Trotter算法能求出 n-1 个数的全排列，那么Johnson-Trotter算法就能求出 n 个数的全排列。

  显然当只有一个数的时候结果就是一个数的全排列。

  由归纳法，Johnson-Trotter算法能生成全排列。
  
- ```java
  public class JohnsonTrotter {
      private int arrangementNum;//排列元素数目
      private ArrayList<ArrayList<Node>> squences;//最终生成的数目
  
      public JohnsonTrotter() {
          squences = new ArrayList<ArrayList<Node>>();
      }
  
      public ArrayList<ArrayList<Node>> generateArrangement(int num) {
          //如果数目小于2就直接进行特殊处理返回
          if (num == 0) {
              return null;
          } else if (num == 1) {
              ArrayList<Node> arrangement = new ArrayList<Node>();
              arrangement.add(new Node(1, -1));
              squences.add(arrangement);
              return squences;
          } else {
              //设置排列数目
              arrangementNum = num;
              //接下来使用生成算法
              generate();
              return squences;
          }
      }
  
      //johnsontrotter生成逻辑
      private void generate() {
          //先生成一个序列顺序
          ArrayList<Node> tempList = generateFrist();
          //加入序列组中
          squences.add(tempList);
          //一直循环直到这个序列不能进行移动
          int subscript;//记录最大可移动下标
          int lastMoveValue = arrangementNum + 1;//记录在没有移动可移动元素时上一次的可移动元素的值
          //在循环中每次循环都要去找最大可移动元素浪费资源且效率低下，建议抽出一个函数直接判定两个元素是不是能够进行移动。
          while ((subscript = checkMove(tempList)) != -1) {
              //开始复制移动队列
              ArrayList<Node> newList = (ArrayList<Node>) tempList.clone();
              //确定移动的方向
              Node tempNode = newList.get(subscript);
              //记录移动元素的值
              lastMoveValue = tempNode.getVlaue();
              if (tempNode.getPoint() == 1) {
                  newList.set(subscript, newList.get(subscript + 1));
                  newList.set(subscript + 1, tempNode);
              } else {
                  newList.set(subscript, newList.get(subscript - 1));
                  newList.set(subscript - 1, tempNode);
              }
              //移动完成加入序列组
              squences.add(newList);
              //更新序列，下次是对这个序列进行移动操作,这里可以进行改良---比较当前最大移动元素与下个移动位置的元素是否能继续移动，能就直接移动，不能再去寻找
              tempList = newList;
              //调转所有大于K的方向
              checkAndTurn(tempList, lastMoveValue);
          }
      }
  
      //初始序列
      private ArrayList<Node> generateFrist() {
          ArrayList<Node> temp = new ArrayList<Node>();
          for (int i = 0; i < arrangementNum; i++) {
              temp.add(new Node(i + 1, -1));
          }
          return temp;
      }
  
      //找到给定序列的最大可移动元素的下标,如果有就返回下标，如果没有就返回-1
      private int checkMove(ArrayList<Node> checkList) {
          int flag = -1;//如果没有就返回-1
          //循环遍历,因为整个序列的元素个数都是arrangementNum
          for (int i = 0; i < arrangementNum; i++) {
              //检查该位置上的元素的指向
              if (checkList.get(i).getPoint() == -1) {
                  //指向左边，先检查是否越界，越界就跳过这个位置
                  if (i > 0) {
                      //否则就比较元素的大小，大则不能移动，跳过，小则能移动更新flag,不存在等于的情况奥
                      if (flag == -1) {
                          if (checkList.get(i).getVlaue() > checkList.get(i - 1).getVlaue()) {
                              flag = i;
                          }
                      } else {
                          if (checkList.get(i).getVlaue() > checkList.get(i - 1).getVlaue() && checkList.get(i).getVlaue() > checkList.get(flag).getVlaue()) {
                              flag = i;
                          }
                      }
                  }
              } else {//如果指向右边
                  //指向右边，先检查是否越界，越界就跳过这个位置
                  if (i < arrangementNum - 1) {
                      //否则就比较元素的大小，大则不能移动，跳过，小则能移动更新flag,不存在等于的情况奥
                      if (flag == -1) {
                          if (checkList.get(i).getVlaue() > checkList.get(i + 1).getVlaue()) {
                              flag = i;
                          }
                      } else {
                          if (checkList.get(i).getVlaue() > checkList.get(i + 1).getVlaue() && checkList.get(i).getVlaue() > checkList.get(flag).getVlaue()) {
                              flag = i;
                          }
                      }
                  }
              }
          }
          return flag;
      }
  
      //检查当前队列是否存在比移动元素值要大的值，有就进行箭头方向调转
      private void checkAndTurn(ArrayList<Node> arrayList, int maxMove) {
          for (Node node : arrayList) {
              if (node.getVlaue() > maxMove) {
                  //因为左为-1，右为1，乘-1即可调转
                  node.setPoint(node.getPoint() * -1);
              }
          }
      }
  
      public static void main(String[] args) {
          ArrayList<ArrayList<Node>> squence = new JohnsonTrotter().generateArrangement(5);
          if (squence != null) {
              squence.sort(new Comparator<ArrayList<Node>>() {
                  @Override
                  public int compare(ArrayList<Node> o1, ArrayList<Node> o2) {
                      int flag = 0;
                      for (int i = 0; i < o1.size(); i++) {
                          if (o1.get(i).getVlaue() > o2.get(i).getVlaue()) {
                              flag = 1;
                              break;
                          } else if (o1.get(i).getVlaue() < o2.get(i).getVlaue()) {
                              flag = -1;
                              break;
                          } else {
                              flag = 0;
                          }
                      }
                      return flag;
                  }
              });
              for (ArrayList<Node> arrayList : squence) {
                  for (Node node : arrayList) {
                      System.out.print(node.getVlaue());
                  }
                  System.out.println();
              }
              System.out.println("总计数目：" + squence.size());
          }
      }
  }
  ```

  ##### 2.3.1.3字典排序法
  
- 顾名思义：就是按照字典顺序一样将元素从小到大进行排列，排列顺序从小到大。而生成序列的顺序也是如此。起始我们指定序列就是升序。而首先就是验证末尾两个元素的大小，末尾大就交换两者的位置，小就说明这个最大的值一定在前面，要么整体是逆序的，要么就一定至少存在一个2个元素的逆序序列。而逆序序列就说明了，从逆序开始的地方已经到达瓶颈，这个逆序序列中的所有元素的全排列完全生成了。那么我们就需要按照字典顺序改变逆序列的前一个元素a，也就是需要和逆序列中最小的大于a的值m进行位置交换，而这个m就是一个分割点。交换完成后逆序仍然保持逆序，需要将其转换为正序，这样就仅仅只是按字典顺序改变了一个元素的大小，接着又从按照字典顺序开始生成。（你真的能够保证你逆序后，逆序中的元素全排列已经生成完成？确实是，因为开始就是顺序的然后就从最后两个元素交换开始。就是从全排列开始的，接着每次交换元素我们就像插入法进行元素插入一样）

  ```java
  public class DictionaryGenerate {
      private int arrangementNum;
      private ArrayList<ArrayList<Integer>> squences;
  
      public DictionaryGenerate() {
          squences = new ArrayList<ArrayList<Integer>>();
      }
  
      //使用字典法生成序列
      public ArrayList<ArrayList<Integer>> dictionaryGenerate(int num) {
          if (num == 0) {
              return null;
          } else if (num == 1) {
              ArrayList<Integer> arrayList = new ArrayList<Integer>();
              arrayList.add(1);
              squences.add(arrayList);
              return squences;
          } else {
              //设置排列值
              arrangementNum = num;
              //先升序初始化序列
              ArrayList<Integer> tempList = upInit();
              //加入序列组
              squences.add(tempList);
              //循环检测
              while (true) {
                  //先复制一份
                  ArrayList<Integer> newList = (ArrayList<Integer>) tempList.clone();
                  //判断结尾两个数的大小,尾大则交换，否则寻找逆序列。
                  if (newList.get(arrangementNum - 1) > newList.get(arrangementNum - 2)) {
                      int tempElemnet = newList.get(arrangementNum - 1);
                      newList.set(arrangementNum - 1, newList.get(arrangementNum - 2));
                      newList.set(arrangementNum - 2, tempElemnet);
                  } else {
                      //找逆序列起始下标
                      int subscript = findDown(newList);
                      //如果大于说明还能生成序列
                      if (subscript > 0) {
                          //存在就找到min的下标{反序列>newList.get(arrangementNum - 1)}
                          int temp = findMinGreater(newList, subscript);
                          //交换两者的位置
                          if (temp > -1) {
                              int tempElement = newList.get(subscript - 1);
                              newList.set(subscript - 1, newList.get(temp));
                              newList.set(temp, tempElement);
                          }
                      } else {//如果等于0就说明不能生成了
                          break;
                      }
                      //然后将这个逆序序列反向排列
                      reverse(newList, subscript);
                  }
                  //现在再将这个序列加入序列组中
                  squences.add(newList);
                  //修改前驱序列
                  tempList = newList;
              }
              return squences;
          }
      }
  
      //初始化序列
      private ArrayList<Integer> upInit() {
          ArrayList<Integer> arrayList = new ArrayList<Integer>();
          for (int i = 1; i <= arrangementNum; i++) {
              arrayList.add(i);
          }
          return arrayList;
      }
  
      //找逆序起始下标,如果找到了就返回下标，否则返回-1
      private int findDown(ArrayList<Integer> arrayList) {
          //0不进行验证直接返回
          for (int i = arrangementNum - 2; i > 0; i--) {
              //如果前面的元素要大于当前元素就继续
              if (arrayList.get(i) > arrayList.get(i - 1)) {
                  return i;
              }
          }
          return 0;
      }
  
      //找最小大于i的值的下标
      private int findMinGreater(ArrayList<Integer> arrayList, int sIndex) {
          int min = arrangementNum + 1;
          int sub = -1;
          for (int i = sIndex; i < arrangementNum; i++) {
              int temp = arrayList.get(i);
              if (temp > arrayList.get(sIndex - 1) && temp < min) {
                  min = temp;
                  sub = i;
              }
          }
          return sub;
      }
  
      //反向排列逆序序列
      private void reverse(ArrayList<Integer> arrayList, int sIndex) {
          int left = sIndex;
          int right = arrangementNum - 1;
          while (left < right) {
              int tempElement = arrayList.get(left);
              arrayList.set(left, arrayList.get(right));
              arrayList.set(right, tempElement);
              left++;
              right--;
          }
      }
  }
  ```
  
  

#### 2.3.2生成子集(这是属于组合问题)

- 问题描述1：集合A的幂集是指以集合A的所有子集为元素组成的集合。



##### 2.3.2.1减治法生成幂集

- 减治法生成幂集。使用自底向上方式，也就是从空集一直选取元素增加到集合本身。求n的幂集=在n-1的幂集中添加元素n。

  - 缺点：在求解规模为n的问题时需要知道规模为n-1的解。也就是说如果我们本身不需要n-1的结果，但是却在中间计算了它的解，可以说这是浪费了时间和空间来计算n-1的。（可见这会产生过多的中间结果）

  ![](..\图片\20211024182612.jpg)

  ```java
  public class RedcutionTreatment<T> {
      private TreeSet<T> inSet;
      private ArrayList<TreeSet<T>> outPowerSet;
  
      public RedcutionTreatment(TreeSet<T> inSet) {
          this.inSet = inSet;
          outPowerSet = new ArrayList<TreeSet<T>>();
          //添加空子集,因为集合框架中存的都只是对象的引用，添加空引用没问题。
          outPowerSet.add(null);
      }
  
      //使用减治法思想计算输入集合的幂集
      public ArrayList<TreeSet<T>> powerSet() {
          //先检查inSet是否为空，是就返回空子集，不是才调用
          if (inSet != null) {
              //调用生成法，使用自底向上的增量方式
              generate();
          }
          return outPowerSet;
      }
  
      //生成幂集
      private void generate() {
          //因为序列中已经存在空集就不需要再添加了。
          //进入循环，循环执行结束是所有输入集合中的元素都添加到了前一个集合中。
          for (T t : inSet) {
              //这里我们使用的是treeset，所以我们没法直接获取要插入的元素,但是他是有序的，所以直接遍历它
              //获取原序列大小
              int oldSize = outPowerSet.size();
              int i = 0;
              //循环原序列
              while (oldSize > 0) {
                  //遍历原序列
                  TreeSet<T> tempSet = outPowerSet.get(i);
                  //如果为空集就新建一个集合并且添加元素
                  if (tempSet == null) {
                      tempSet = new TreeSet<T>();
                      tempSet.add(t);
                      //添加到幂集
                      outPowerSet.add(tempSet);
                  } else {
                      //否则就复制一份，然后添加元素
                      TreeSet<T> newSet = (TreeSet<T>) tempSet.clone();
                      newSet.add(t);
                      //添加到幂集
                      outPowerSet.add(newSet);
                  }
                  //循环完成大小减一
                  oldSize--;
                  //访问下一个元素
                  i++;
              }
          }
      }
  }
  ```


##### 2.3.2.2位串法生成子幂集

- 概述：方法：输入集合的每一个子集与一个n位二进制串对应，将输入集合的每个元素按照一定顺序排列，二进制串每位对应着序列上的一个元素，某位上的值为0 表示这个输入集合中的这个元素不属于这个子集，为1则表示属于。

  ![](..\图片\20211025140615.jpg)

- 所以我们可以使用的解题思路：

  - 将输入集合只做输出时查询使用
  - 现在将幂集生成为题转换为二进制字符串全部组合问题。
  - 解决这个问题的方式，我们可以使用二进制加一方式全部生成。000、001、010...。甚至如果不存储的话我们可以直接打印出结果就行。
  
- ```java
  
  /**
   * 使用位串生成幂集
   */
  public class StringGenerate {
      private ArrayList<byte[]> results;
  
      public StringGenerate() {
          results = new ArrayList<byte[]>();
      }
  
      //生成位串
      public ArrayList<byte[]> generateString(int num) {
          //新建一个位串
          byte[] newString = new byte[num];
          results.add(newString);
          //循环遍历生成位串
          while (true) {
              //我们采用二进制逐步加一的方式进行位串生成
              byte[] temp = autoIncrease(newString);
              //如果不为空就直接加入否则退出循环
              if (temp != null) {
                  results.add(temp);
                  //修改下次处理的位串
                  newString = temp;
              } else {
                  break;
              }
          }
          return results;
      }
  
      //位串自增
      private byte[] autoIncrease(byte[] bytes) {
          byte[] newbyte = bytes.clone();
          //从低位开始遍历
          for (int i = newbyte.length - 1; i >= 0; i--) {
              //如果低位加一之后对2取余的值为1，直接返回即可。否则就下一位+1再次验证
              newbyte[i] = (byte) ((newbyte[i] + 1) % 2);
              if (newbyte[i] == 1) {
                  return newbyte;
              }
          }
          //如果最终加出的结果全为0，就返回null
          return null;
      }
  }
  ```

- 如果我们还需要按照挤压序生成，就还需要一个排序算法

  ```java
      //挤压排序
      public ArrayList<byte[]> extrusion(ArrayList<byte[]> arrayList,int num){
          //将全0排除在外
          for(int i=1;i<arrayList.size()-1;i++){
              //使用选择排序
              int min=i;
              for(int j=i+1;j<arrayList.size();j++){
                  //从最低位开始扫描，有1放后面，0放前面，相等就比较前一位一位。
                  for(int k=num-1;k>=0;k--){
                      if(arrayList.get(min)[k]>arrayList.get(j)[k]){
                          //更新下标
                          min=j;
                          //退出本次，比较下一个元素
                          break;
                      }else if(arrayList.get(min)[k]==arrayList.get(j)[k]){
                          //相等就比较下一位
                      }else {
                          //min仍然是最小的，直接退出,比较下一个元素
                          break;
                      }
                  }
              }
              //找出最小的然后进行位置交换
              if(min!=i) {
                  byte[] temp = arrayList.get(min);
                  arrayList.set(min,arrayList.get(i));
                  arrayList.set(i,temp);
              }
          }
          return  arrayList;
      }
  
  ```
  
  

##### 2.3.2.3挤压序

- 概述：所有包含元素aj的子集必须紧排在所有包含a1、a2...,aj-1的子集后面。换句话说，我们要将n-1的子集生成完了，才能生成n（通过减治法生成的序列顺序就是挤压序），但是我们通过位串进行生成就不是挤压序。所以要使得位串生成的是挤压序，我们需要将生成的序列进行排序。从第一位开始，全0排外，为1的放前面，依次每位进行比较，直到所有位比较完。

  - 存在的问题：但是我们知道这样在生成好之后再次进行排序是耗费性能，最快的排序也是O(n*logn)。且排序的输入规模是2^n（n代表集合元素数目）。

- 解决位串法生成幂集具有一定规律性问题：

  - 是否存在一种生成位串的最小变化算法，使得每一个位串和它的直接前驱之间仅仅相差一位。

  - 特征：对于子集，每一个子集和它的直接前驱之间的区别是，要么增加一个元素，要么删除一个元素，但是两者不能同时发生。（因为1代表存在、0代表不存在，又要求变化最小，故推出特征）

  - 具体方法：使用**二进制反射格雷码**实现(又叫做循环二进制码、反射二进制码)

  - 反射格雷码理解：

    - 最大特征就是每一个编码串与前驱只相差一个位置的改变，且首串和尾串也是如此，所以形成一个环，也叫做反射。
  
  - [格雷码_百度百科 (baidu.com)](https://baike.baidu.com/item/格雷码/6510858?fr=aladdin)
  
  - [格雷码的优势_化工仪器网 (chem17.com)](https://www.chem17.com/tech_news/detail/1356942.html)
  
    - 伪代码：
  
      ```tex
      算法BRGC(n)
      //递归生成n位二进制反射格雷码
      //输入：一个正整数n
      //输出：所有长度位n的格雷码位串列表
      if n=1,表L包含位串0和位串1
      else 调用BRGC(n-1)生成长度为n-1的位串列表L1
      	 把表L1倒序后复制给L2
      	 把0加到表L1中的每个位串前面
      	 把1加到表L2中的每个位串前面
      	 把表L2添加到表L1后面得到表L
      return L
      //这种方式为什么能够生成格雷码，因为每次添加时都是在最少变化的基础上添加相同的元素0，所以仍然保证最少变换
      //而每添加一位，这一位上只存在两种可能0、1所以复制一份添加1得到表集2，使得原来的表集每添加一位所有可能都保证。然后是倒序，连接。连接位置在没添加之前是完全相同的，而一个添加0、一个添加1，所以保证了两者变化最少。而这个分界点又都是局部最少变化的（其实有点分治法的感觉在里面），所以最终全局最少变化。
      ```
      
    - 反射格雷码的生成方式有很多种,这里就使用上面那种
    
      ```java
      public class BRGC {
          //因为它采用的方式添加0、1的方式，所以我们使用字符串来存储结果集
          public ArrayList<String> brgcString(int num){
              if(num==0){
                  return null;
              }else {
                  return recursion(num);
              }
      
          }
      
          //递归调用此方法
          private ArrayList<String>recursion(int num){
              //如果为1就添加0、1两者到表种，返回即可
              if(num==1){
                  ArrayList<String> strings=new ArrayList<String>();
                  strings.add("0");
                  strings.add("1");
                  return strings;
              }else {
                  //先将n-1的结果集倒序复制一份
                  ArrayList<String> strings1= recursion(num-1);
                  ArrayList<String> strings2= new ArrayList<String>();
                  int size=strings1.size();
                  //进行倒序复制
                  for(int i=size-1;i>=0;i--){
                      strings2.add(strings1.get(i));
                  }
                  //然后在s1所有位串前添加0，s2添加1,这里Java循环中使用StringBuilder最好
                  for(int i=0;i<size;i++){
                      strings1.set(i,"0"+strings1.get(i));
                      strings2.set(i,"1"+strings2.get(i));
                  }
                  //然后将列表2放在列表1后
                  //将s2全部加入
                  strings1.addAll(strings2);
                  //返回s1
                  return strings1;
              }
          }
      }
      ```
    
      

### 2.4减常量因子算法

- 减常量因子算法常常具有对数时间效率，非常高效，实例不多。常以2为因子进行化简，如折半查找。

- 折半查找原理：对于有序数组（升序），通过比较查找键K和数组中间元素A[m]=A[l+r]/2
  - 如果K=A[m],结束

  - 如果小于，则在左边（前部）继续执行查找

  - 大于，就在右边（后部）继续执行查找

  - 效率分析：

    - $$
      C_{worst}(n)=C_{worst}(n/2)+1,C(1)=1
      \\
      设n=2^k
      \\
      C_{worst}(n)=k+1=log_2n+1
      \\
      于是C_{worst}(n)∈Θ(log_2n)
      \\
      C_{worst}=k+1=log_2n+1经过调整后使用于任意正整数n
      C_{worst}(n)=log_2n+1
      \\
      即最坏情况下折半查找的时间效率是Θ(log_2n)
      $$

      

    ```java
    public class BinarySearch {
        //输入一个升序数组进行,必须要实现compareable接口,找到就返回下标,没有就返回-1
        public <T> int search(T[] array, T k) {
            //初始化左右边界
            int left = 0;
            int right = array.length - 1;
            int middle;
            while (left <= right) {
                //比较数据
                int compare = ((Comparable<T>) array[middle = (left + right) / 2]).compareTo(k);
                if (compare == 0) {
                    return middle;
                } else if (compare == -1) {
                    right = middle - 1;
                } else {
                    left = middle + 1;
                }
            }
            return -1;
        }
    }
    ```

- 假币问题

  - 问题描述：有n个金币，其中有一个假币。这个假币的重量比真币的重量要轻一点。所有n-1个金币的重量是一样的。现在又一家天平，设计高效算法（用最少的使用天平次数）找出假币。
  
  - 解法1：用减治法（减法）
    - 把n个硬币分为两堆，进行比较。选出轻的一堆再比较。直到找出假硬币。（要区分奇偶）
    
  - 解法2：同样使用减治法，将其分为3堆进行比较。那么效率分析就是每次减少的常量因子为3。那么又推导可知：Θ(log3N)。由对数的比较可知：Θ(log3N)<Θ(log2N)。由指数与对数的对称性也能够进行推断。
  
  - 引出的问题：是否将其分的部分越多就效率就越高。现在我们就假币问题，假设将其分为n堆。那么我们的最坏比较次数：
  
    
  
    
  
    - $$
      每次比较两个元素：然后将其排除在外。
      C_{worst}(n)=n/2,
      \\所以推出效率为Θ(N)
      \\从这点上我们可以得知，分的越小不一定越好，现在已经退化为Θ(N)
      \\那么产生这样的原因是什么？
      \\我们可以使用树结构进行解析：假设将输入规模N划分为2......n份
      \\那么可以感觉出树的高度再逐步降低，宽度逐步增加。
      \\那么可以推出我的树宽之间的递归比较次数（同层之间的比较次数+子树同层的比较次数）应该是存在一个最大值点。
      \\在这个点我们进行划分部分是使得该算法达到效率最高，然后就会逐步降低。
      $$
  
  - 在实际划分时，我们可以根据输入规模的值的特点（在数值方面的特点）进行划分。
  
  ```java
  ```
  
- 俄式乘法：[俄式乘法_我们都要好好的_52444_新浪博客 (sina.com.cn)](http://blog.sina.com.cn/s/blog_12b0bcb610102wnt7.html)

  - n*m。result为最终的结果

  - n不断除2，m不断乘2，直到n为1为止。如果n除2有余数，就m乘2后的数则加上最终的结果。

    ```java
    public class RussianFarmer {
        //乘法
        public static int multiplication(int num1, int num2) {
            //初始化数
            int n = num1;
            int m = num2;
            //最终的结果
            int result = 0;
            while (n != 1) {
                //如果n除2有余数就
                if (n % 2 == 1) {
                    result += m;
                }
                //m乘2
                m = m << 1;
                //n除2
                n = n >> 1;
            }
            result += m;
            return result;
        }
    }
    ```
    
    

- 约瑟夫斯环问题：将n个元素进行编号，按顺序成环。从1开始计数，指定标号i,如果计数到i就将这个元素删除，直到留下最后一个元素。求这个幸存的编号

  ```java
  public class JosephusRing {
      public static int survivors(int elementNum, int count) {
          //如果count为1直接返回elementNum
          if (count == 1) {
              return elementNum;
          }
          //为了便于删除使用链表存储状态,用数组0、1标识状态也行,数组要形成环就需要使用下标取余的方式进行形成。
          //头节点
          Node firstNode = new Node(1, null);
          //尾插法，创建链表的移动指针
          Node move = firstNode;
          for (int i = 2; i <= elementNum; i++) {
              //新建节点
              Node node = new Node(i, null);
              //将上个节点指针指向这个节点
              move.setNext(node);
              //移动创建指针到尾部
              move = node;
          }
          //要形成环，首尾相连
          move.setNext(firstNode);
          //循环计数
          int countNum = 1;
          //遍历指针从头开始
          Node traverse = firstNode;
          //只剩下一个节点结束
          while (traverse.getNext() != traverse) {
              //获取下一个节点
              Node temp = traverse.getNext();
              //计数
              countNum++;
              //判断当前计数是否符合条件，是就删除，并且重置count
              if (countNum == count) {
                  //删除节点
                  traverse.setNext(temp.getNext());
                  //计数重新开始
                  countNum = 1;
              }
              //每次循环需要更新遍历指针指向
              traverse = temp;
          }
          //返回这个节点的值
          return traverse.getSubscript();
      }
  }
  ```

  - 约瑟夫斯环问题进一步分析：

    - 前提条件：每轮消去的元素计数是2

    - 当n为偶数时，对整个环的处理是消去偶数位置上的元素。那么就是说问题的规模在每次消去后规模减半(1/2)，而新的环又是同样的问题，当问题规模变为1时结束算法。

    - 
      $$
      将人数分为奇数n，偶数n考虑。如果n为偶数，n=2k，一轮之后，规模减半。\\
      3到了2个位置，5到了3的位置，7到了4的位置。\\
      为了得到一个人的初始位置，需要将他的新位置乘2减1，\\
      对于幸运者这个关系会一直持续下去：\\
      （幸存者是活到最后的人，肯定满足这个关系。）\\
      J(2K)=2J(K)-1\\
      理解这个公式的前提：只记录新一轮的标号，然后反推它最起始的标号\\
      这个公式需要反过来看，因为最终得到的是幸存者在最后一轮的标号，但是每一轮标号之间存在对应的关系,故能反推\\\\
      对于基数n，n=2k+1，第一轮会消去所有偶数位的人，同时把位置1的人消去，\\
      3到了1个位置，5到了2的位置，7到了3的位置
      留下了一个规模为k的例子，新位置编号和旧位置之间的关系为：\\
      J(2K+1)=2J(K)+1\\
      同上的理解\\
      \\
      所以我们可以将求2K或2K+1转换为求K。逐次减少规模。可以使用递归和非递归实现\\
      但是，下面是我想说的：
      综合一下：我们知道最后幸存者的编号一定是1，那么我们可以不用再去通过数据结构进行存储模型;\\
      而是直接通过这个关系式进行替换反推出最终的幸存者标号。尽量将数据与逻辑分开，也许这样会减少内存的消耗\\
      $$
      

- 
  
  ```java
  public class Backsteeping {
      //使用递归实现,消去的是2
      public static int survivorsRecursion(int elementNum) {
          //如果为1就直接返回1
          if (elementNum == 1) {
              return 1;
          } else if (elementNum % 2 == 0) {
              //如果为偶数按照下列关系
              return 2 * survivorsRecursion(elementNum / 2) - 1;
          } else {
              //如果为奇数按下列关系式
              return 2 * survivorsRecursion(elementNum / 2) + 1;
          }
      }
  
      //使用非递归实现
      public static int survivorsRecursionN(int elementNum) {
          if (elementNum == 1) {
              return 1;
          }
          //使用栈存储中间K值。因为我们无法确定所有的中间的J数是奇数还是偶数，记录奇偶就行
          ArrayList<Integer> stack = new ArrayList<Integer>();
          //循环计算K,直到K=1
          while (elementNum != 1) {
              if (elementNum % 2 == 1) {
                  stack.add(1);
              } else {
                  stack.add(0);
              }
              //右移一位
              elementNum >>= 1;
          }
          //逐步出栈元素计算J(n)
          //初始为1
          int survivor = 1;
          //为了减少代码的执行量我们直接通过循环反向遍历每个元素,不进行删除
          for (int i = stack.size() - 1; i >= 0; i--) {
              //如果为奇数就2K+1
              if (stack.get(i) == 1) {
                  survivor = survivor * 2 + 1;
              } else {
                  survivor = survivor * 2 - 1;
              }
          }
          return survivor;
      }
  }
  /*
   通过测试发现使用递归与使用人工栈实现的非递归算法时间比较：406、2380。可见使用人工栈实现非递归远没有递归的效率高为什么？
          我们直到Java执行方法的流程是这样的：在一个虚拟机栈中，遇见一个方法就入栈，形成一个栈帧。然后执行栈顶方法。
           而这期间产生的局部变量都应该放在各自的栈帧中。那么递归就是不断往虚拟机栈中加入栈帧然后从栈顶开始执行。
           而栈帧的入栈与出栈必然是需要虚拟机的开销。
           现在想想我们使用人工栈实现不需要进行大量的栈帧的入栈出栈操作。但是为什么效率反而低。
           都是减常量因子的算法，那么差异应该是在算法实现的细节上，我们非递归需要先计算每次除2后的奇偶性，然后入栈，而后面还需要进行判断，
           然后进行计算下标。
           可见引起差异的主要下标就是前面入栈部分，递归是虚拟机将栈帧入栈，非递归还需要进行计算后将结果入栈。
           综上比较：
           有以下特点：
           1、对于只有基本型变量，一般来说栈帧的大小要比我们人工栈要大，也就是，在该算法中递归耗费的空间要大
           2、两者有相同的操作代码，而主要不同在于
              递归的：栈帧的入栈与出栈，
              非递归的：堆空间开辟，元素计算，计算结果入栈出栈，再往细究就是硬件磁盘的寻址算法相关
              那么我们可知：如果后者总体耗费时间如果高于前者，那么递归高、否则非递归高，这两者之间存在一个临界值。
                           使用非递归一定有以下好处：空间可控，栈溢出风险小，从而安全性高，线程的开销小
                           而递归于非递归的具体比较需要考虑的因素很多，所以非递归的实现方式的选取要符合需求懂得取舍
  */
  ```
  
  
  
- 下面是使用循环左移的方法解决约瑟夫环

  

  ```java
  /*
   * 将输入规模转化为二进制
   * 通过循环左移一位的方式确定最终的幸存者
   *
   * */
  public class CyclicLeft {
      public int survivor(int elementNum) {
          //先将元素数目转换为二进制
          byte[] temp = conversionBinary(elementNum);
          //再将其循环左移
          cyclicLeft(temp);
          //将二进制转换为十进制
          return conversionOct(temp);
      }
  
  
      //除2取余法
      private byte[] conversionBinary(int octNum) {
          ArrayList<Byte> stack = new ArrayList<Byte>();
          //标识
          int consult = octNum;
          int surplus = 0;
          while (consult != 0) {
              surplus = consult % 2;
              consult /= 2;
              stack.add((byte) surplus);
          }
          byte[] result = new byte[stack.size()];
          for (int i = stack.size() - 1; i >= 0; i--) {
              result[result.length - 1 - i] = stack.get(i);
          }
          return result;
      }
  
      //循环左移
      private void cyclicLeft(byte[] temp) {
          byte tempElement = temp[0];
          for (int i = 1; i < temp.length; i++) {
              temp[i - 1] = temp[i];
          }
          temp[temp.length - 1] = tempElement;
      }
  
      //转换为十进制
      private int conversionOct(byte[] temp) {
          int sum = 0;//最终的结果
          int mul = 1;//每位转换为十进制
          for (int i = 0; i < temp.length; i++) {
              if (temp[i] == 1) {
                  mul <<= temp.length - 1 - i;
                  sum += mul;
                  mul = 1;
              }
          }
          return sum;
      }
  }
  ```

### 2.5减可变规模算法

#### 2.5.1计算中值和选择问题

- 选择问题：求n个数列表的第K个最小元素（也称第K个书顺序统计量）或者是求k是n个数列表中的第几小元素。
  - 当k=（n/2）下取整时，元素比列表中的一般元素大，又比另一半元素小，该元素被称为中值。
  - 可以先把列表进行排序，然后从排序算法的输出选出第k个元素。算法的运行时间取决于所选用排序算法的效率。
  - 问题：是否存在不排序就能解决这一问题的算法？
  - 划分思路：将一个给定列表更具某个值p(如列表的第一个元素)进行划分。
    - 划分思路：对列表元素的重新整理，使左边部分包含所有小于或等于p的元素，紧接着是所有大于或等于p的元素。
  - 划分算法主要有：Lomuto划分、霍尔（Hoare）划分。
  
- Lomuto划分思想：考虑数组，或一个子数组A[l...r]（0<=l<=r<=n-1）,该数组由连续的三段组成，这三段按顺序排在中轴p的后面：一段为已经小于p的元素，一段为已经大于或等于p的元素，还有一段还未同p比较过的元素。
  - 将数组元素挨个与中轴进行比较，然后将其放在该放的段中。
  
- 利用划分来寻找第k个最小元素--快速选择算法原理：

  - 设列表以数组实现，元素索引从**0**开始，而s是划分的分割位置（s之前比中轴小，s之后大于等于中轴）
  - 如果s=**k-1**,中轴p本身就是第k小的元素，算法结束。
  - 如果s>**k-1**整个列表的第k小元素是被划分数组左边部分的第k小元素。
  - 如果s<**k-1**，整个列表的第k小元素是被划分数组右边的第k-s小元素。

- 

  ```tex
  利用划分来寻找第K个最小元素-快速选择算法
  1、为什么说它是可变规模的算法？
   因为每次划分需要将中轴与输入的数组的所有元素进行比较，
   而下一次还需要比较的次数（或者说下次处理的子数组的规模）
   取决于上次得到的中轴位置的结果。
   所以每次处理的规模是不确定的。但一定是减少的。
  2、为什么说它的效率比使用一般的排序算法要高？
      拿选择排序说，每次都需要和原始的数组的规模减一进行比较，
      那么最终的比较次数就是n（n-1）/2次，当然如果我们不完全排序，
      直接在K处退出，则大概次数就是k（n-1）/2.那么明显就需要看k的实际取值。
  
      而使用划分第一次需要将全部元素进行比较就是n-1次，
      而接下来
      最坏的情况：
      就是中轴位于起始位置，剩余元素还需要进行n-2次比较，那么就和选择排序等同了。
      而最好的情况：
      当前就是要选择的值，直接返回。
      那么普遍的情况：
      要寻找的最终结果在当前中轴的两侧，那么至少说每次减少的规模必然>1.
      那么意味着比较的次数必然会更少。
      且大概率随着每次比较的深入，规模在大幅度减少。
  ```

  

  ```java
  public class Lomuto {
      //为了统一我们使用泛型数组
      //两者是下标
      //返回中轴下标
      public <T> int division(T[] array, int l, int r) {
          //记录中轴
          T axis = array[l];
          //记录每个分段的起始下标
          int s = l;//小于分段的最后一个元素，因为开始没有元素
          //从下一个元素开始比较
          for (int i = l + 1; i <= r; i++) {
              //可能没有实现comparable接口
              //如果当前元素比中轴小就将其与大分段的头部进行交换，就是s+1的下标
              if (((Comparable<T>) axis).compareTo(array[i]) > 0) {
                  //因为s为最后一个小分段的最小元素所以先将其加一。
                  T temp = array[++s];
                  array[s] = array[i];
                  array[i] = temp;
              }
          }
          //因为我们是将中轴元素暂时不动的，所以最终我们需要将其与小分段的最后一个元素进行交换。
          array[l] = array[s];
          array[s] = axis;
          //此时s的位置就是我们的中轴元素位置
          return s;
      }
  }
  ```

- 对应的快速选择算法代码

  - 
    
    ```java
    public class LomutoSelect {
        Lomuto lomuto = new Lomuto();
    
        //使用递归方式进行
        //返回找寻最终的结果，如果要返回的次数需要定义一个数据结构
        public <T> T select(T[] array, int k) {
            return array[recursion(array, 0, array.length - 1, k)];
        }
    
        //返回当前划分下标
        private <T> int recursion(T[] array, int l, int r, int k) {
            int i = lomuto.division(array, l, r);//中轴位置
            if (i == k - 1) {
                //直接返回
                return i;
            } else if (i > k - 1) {
                //如果大就递归划分左边部分找第k个
                return recursion(array, l, i - 1, k);
            } else {
                //如果小于,就递归划分右边部分找第k-i个
                //但是我们使用的是下标所以，仍然找的是k
                return recursion(array, i + 1, r, k);
            }
        }
        //使用非递归实现
        private <T> int recursionN(T[] array, int k) {
            //循环划分直到划分结果为k
            int l = 0;
            int r = array.length - 1;
            int s = lomuto.division(array, l, r);
            while (s != k) {
                if (s < k) {
                    l = s + 1;
                    s = lomuto.division(array, l, r);
                } else {
                    r = s - 1;
                    s = lomuto.division(array, l, r);
                }
            }
            return s;
        }
    }
    ```
    
  - 算法分析
    $$
    -最优：C_{best}(n)=n-1\in Θ（n）,因为对于一个n元素数组进行划分总是要n-1次键值比较，若不需要更多迭代就得到分割位置使问题的解。\\
    -最差（严格递增数组）：C_{worst}(n)=(n-1)+(n-2)+...+1=（n-1）n/2\inΘ(n^2)。\\
    -平均情况：线性效率【严格数学分析已经证明，详情百度】\\
    -计算机科学家发现了一复杂算法用于快速选择中选出中轴，最差情况下效率使线性的，但算法太复杂，不便于实际应用。\\
    -基于划分的算法，得到了给定列表的第k小元素、k个最小元素和n-k个最大元素。
    $$
    
  
- 

#### 2.5.2插值查找

- 一种查找有序数组的算法（例如：电话本上根据姓名的查找顶电话号码、又比如在字典上查找一个单词，我们会先将其查找范围缩小）

- 思路：对于有序数组，查找键值v,若查找成功返回下标值，若失败返回-1.设某次迭代处理的使数组最左边元素A[i]和A[r]之间的部分，假设该数组的值是线性递增的，即沿着穿越（l,A[l]）和（r,A[r]）的直线分布的。

  

  - 
    $$
    通过两点确定直线的公式，可以解的现在所选子数组的直线方程：\\
    y-A[l]={A[r]-A[l]\over r-l}(x-l)\\
    令y=v,解得：\\
    x=l+\lfloor{(v-A[l])(r-l)\over A[r]-A[l]}\rfloor\\
    于是，x为查找键值v的期望位置\\
    减A[l]的原因便于记忆可以想做：因为每次都是将l位置作为起始点，也就是x=0的位置，所以相当于b为A[l],还可以理解为目标与左边界的偏移量。\\实际通过代换就能求得。
    $$
    
  - 

  

- 我的理解：插值查找实际上二分查找的改良版。他们的思想都是尽可能缩小查找区间，所以都是减治法的思想。而插值查找的思路是先将元素递增排列，它默认为它们的排列规律是线性排列，然后将待查找的值v通过这种规律进行映射，从而缩小它查找的区间。那么如果是呈现线性，第一次我们期望的位置就是要查找的元素。而如果不是，我们也能缩小查找区间。

  - 那么是不是说我们只要能够将这组数据的函数式准确确定，不一定使用线性，我们查找的效率就是O(1)?确实如此，那这就有种hash函数味道在里面。但是，有要注意：1、数据很可能具体函数式无解，那么你最多就只能找到它的近似解。2、每组数据的值你都要去通过大量的计算去寻找它的函数式，如果这种代价已经超过了使用线性这种最基本的函数进行查找的代价，就大可不必；当然你的输入数据每次都是特定规律，你可以通过一次计算函数式，后续无数次使用。3、线性的处理方式往往具有普遍性，最坏效率也在O(n).
  - 插值查找区间呈现一种减可变规模变化。它能确定我们最希望查找的位置，从而最大限度的去缩小区间，不是像二分只能通过固有变化去缩小区间。

- 线性插值查找步骤：

  - 1、将数组升序排序
  - 2、通过当前子数组边界两点确定线性函数。
  - 3、通过线性函数以及待查找元素v计算期望查找的位置i.
  - 4、比较位置i上的元素与v的大小，如果大于v就在i的前部分继续查找。如果小于v就在后部分继续查找，如果等于就直接返回。
  - [插值查找 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/133535431)
  - 插值查找平均键值比较次数小于loglog(n)+1
  
- 代码实现

  ```java
  public class InterpolationSearch {
      //插值查找:查找成功返回下标，失败则返回-1,传入的一定是一个升序数组
      //注意：这里我们使用的是int作为元素，但是如果不是，需要将指定元素作为y值，也就是排序标准进行指定。
      public int search(int[] array, int k) {
          //调用实际查找算法
          return recursion(array, 0, array.length - 1, k);
      }
  
      //使用递归实现
      private int recursion(int[] array, int l, int r, int k) {
          //如果l>r就直接返回-1
          if (l > r) {
              return -1;
          } else {
              //计算期望查找的位置,因为我们使用的是同一个数组而并没有进行分段然后从0开始索引，所以最终的结果需要加上边界
              int expect = l+((k - array[l]) * (r - l)) / (array[r] - array[l]);
              //比较与k的大小
              if (k == array[expect]) {
                  //等于就直接返回
                  return expect;
              } else if (array[expect] > k) {
                  //小于就在左边查找
                  return recursion(array, l, expect - 1, k);
              } else {
                  //大于就右边查找
                  return recursion(array, expect + 1, r, k);
              }
          }
      }
      
      
      //使用非递归实现
      private int recursionN(int[] array, int l, int r, int k) {
          //进入循环直到l>r
          while (l <= r) {
              int expext = l + ((k - array[l]) * (r - l)) / (array[r] - array[l]);
              //比较该位置与k
              if (array[expext] == k) {
                  return expext;
              } else if (array[expext] > k) {
                  //左边查找更新r继续循环
                  r = expext - 1;
              } else {
                  //右边查找更新l,r继续循环
                  r = expext - 1;
              }
          }
          //循环结束没有找到
          return -1;
      }
  }
  ```



#### 2.5.3二叉查找树

- 特征：要么是一颗空树，要么满足以下的性质
  - 每个节点作为搜索对象，它的关键字是互不相同的
  - 对于树上的所有结点，如果它有左子树，那么左子树上所有结点的关键字都小于该结点的关键字
  - 对于树上的所有结点，如果它有右子树，那么右子树上所有结点的关键字都大于该结点的关键字
  - 二叉查找树的形成状态与具体输入数据的顺序有关系。
  
- 查找：
  - 如果树为空就查找失败
  - 如果非空就与树的根结点进行比较。如果等于就查找成功，结束算法；小于就在左子树查找；大于就在右子树查找。
  - 根据上面的查找特征，对于平衡的二叉树每次查找输入规模**大致**都在逐步减小为上一次规模的1/2。非平衡暂且不论。
  
- 效率状况：
  - 二叉查找树在最差的情况下，树是严重倾斜到一边的（比如连续插入一个升序或者降序序列）。n个元素的树的高度等于n，查找效率为Θ(n),评论效率可达Θ(logn)
  
- 插入：插入是建立在查找的基础上的，插入的位置与查找的位置基本相同。其效率最差情况下为Θ(n),平均效率可达Θ(logn)。

  ```java
  public class BinarySearchTree {
      //持有一个根节点
      private Node root;
  
      //查找算法
      public Node search(int k) {
          //从根节点开始遍历
          return recursion(root, k);
  
      }
  
      //实际查找逻辑,递归实现
      private Node recursion(Node nRoot, int k) {
          if (nRoot == null) {
              return null;
          }
          //比较根节点的值
          if (nRoot.getValue() == k) {
              return nRoot;
          } else if (nRoot.getValue() < k) {
              return recursion(nRoot.getRight(), k);
          } else {
              return recursion(nRoot.getLeft(), k);
          }
      }
  
      //非递归实现，这里没有必要用栈，直接比较键值以及更新当前根节点即可。
      private Node recursionN(Node nroot, int k) {
          if (nroot == null) {
              return null;
          } else {
              //使用栈进行跟踪
              ArrayList<Node> stack = new ArrayList<Node>(20);
              stack.add(nroot);
              //直到所有元素出栈
              while (stack.size() > 0) {
                  Node temp = stack.get(stack.size() - 1);
                  if (temp.getValue() == k) {
                      return temp;
                  } else if (temp.getValue() > k) {
                      if (temp.getLeft() == null) {
                          return null;
                      }
                      stack.add(temp);
                  } else {
                      if (temp.getRight() == null) {
                          return null;
                      }
                      stack.add(temp);
                  }
              }
              return null;
          }
      }
  
      
      
      
      //插入
      public void insert(int k) {
          //不为空才将进行递归插入
          //root=insertRecursion(root,k);
          insertRecursionN(k);
      }
  
      //实际插入递归实现,因为传入空指针会新开辟一个对象，原来的引用还是空，所以需要返回修改
      //判断是否根节点为空，为空就创建一个新节点，并将其返回，将这个返回值赋给根节点。这样就保证根节点被修改
      //如果不为空，就比较键值，大于根就在右边插入，然后将修改根的右子树。小于同理。最后将根返回。
      //虽然随着数量越来越多，中间有很多没有意义的修改，但是使用有不得不被调用。
      private Node insertRecursion(Node tRoot, int k) {
          //通过递归确定插入位置
          if(tRoot==null){
              tRoot=new Node();
              tRoot.setValue(k);
          }else {
              if (tRoot.getValue()==k){
                  tRoot.setValue(k);
                  return tRoot;
              }else if(tRoot.getValue()>k){
                  tRoot.setLeft(insertRecursion(tRoot.getLeft(),k));
              }else {
                  tRoot.setRight(insertRecursion(tRoot.getRight(),k));
              }
          }
          return tRoot;
      }
  
      //实际插入非递归实现
      private void insertRecursionN(int k){
          //先判定根是否为空
          if(root==null){
              //创建新节点
              root=new Node();
              root.setValue(k);
          }else {
              //不为空就开始找寻插入位置
              Node tRoot=root;//临时根节点遍历指针
              int flag=0;//插入标识
              //直接开始遍历
              while (tRoot!=null){
                  //比较键值
                  if(tRoot.getValue()==k){
                      //相等就直接更新,然后结束
                      tRoot.setValue(k);
                      return;
                  }else if(tRoot.getValue()>k){
                      //大于就在左子树上继续
                      if(tRoot.getLeft()!=null){
                          tRoot=tRoot.getLeft();
                      }else {
                          flag=-1;
                          break;
                      }
                  }else {
                      //小于就在右子树
                      if(tRoot.getRight()!=null){
                          tRoot=tRoot.getRight();
                      }else {
                          flag=1;
                          break;
                      }
                  }
              }
              //最后插入
              if(flag>0) {
                  tRoot.setRight(new Node(k, null, null));
              }else {
                  tRoot.setLeft(new Node(k, null, null));
              }
          }
      }
  
      //遍历
      public void traverse(){
          traverse(root);
      }
  
      //递归遍历，非递归使用栈进行跟踪
      private void traverse(Node tRoot){
          if (tRoot==null){
              return;
          }else {
              traverse(tRoot.getLeft());
              System.out.println(tRoot.getValue());
              traverse(tRoot.getRight());
          }
      }
  }
  ```




#### 2.5.4拈游戏

- 单堆游戏问题描述：有一堆n个棋子，两个玩家轮流从堆中拿走最少1个、最多m个棋子，每次拿走的棋子数可以不同，但能够拿走的上下限数量是不变的。如果玩家每次都做出最佳选择，那个玩家能够胜利拿到最后的棋子？先走的，还是后走的？

- 衍生问题：多堆游戏、威氏游戏、费氏数列及进位法。[拈及其各种变形游戏 张镇华 - 百度文库 (baidu.com)](https://wenku.baidu.com/view/91f2b967f02d2af90242a8956bec0975f465a427.html)

- 问题解析：目标肯定以自我赢为目的
  - n=0,败局。因为接下来要走的玩家第一个变为无路可走的玩家。
  - 1<=n<=m,胜局。
  - n=m+1,败局
  - m+2<=n<=2m+1,胜局。因为第一步之后可以给对方留下m+1个
  - n=2m+2,败局。为什么？因为你无论拿走多少个都是转变为第三种情形，也就是说对方如果不傻，必胜。
  - 那么以此类推。使用数学归纳法我们能够得出：当且仅当n不是m+1的倍数时，n个棋子的实例是一个胜局，胜利的策略是每次拿走nmod(m+1)--为什么很明显，拿走这么多后，对手的局的就是m+1的整数倍，如果背离这个策略，则对手持有胜局。
  
- 多堆拈游戏：拈游戏包含I>1堆棋子，没对的棋子数分别是n1,n2,...,ni。每次走的时候，玩家可以从任意一堆棋子种拿走任意允许数量的棋子，甚至可以把一堆都拿光，最后拿光所有棋子的玩家胜。

  - 解法：由鲍顿发现-可以基于堆中二进制数位和(拈和)来实现。

  - 设每堆的棋子数对应的二进制标识分别是b1,b2,.....bi，由棋子数目的十进制计算出各自的二进制表示，然后进行求他们的二进制数位和，也称拈和，即对每一位分别求和并忽略进位（如果该位和是偶数就是0，如果是奇数就为1）

  - 规律结论：当且仅当二进制数位和包含至少一个1时，拈游戏的实例是一个胜局。反之，当且仅当二进制数位和只包含0时拈游戏时一个败局。

    ```java
    public class NimAnd {
        //求解先手是胜局还是败局
        public String victory(int[] heap) {
            //计算拈和
            byte[] nimAnd = getNimAnd(heap);
            //循环遍历寻找是否有 1
            for (byte b : nimAnd) {
                if (b == 1) {
                    return "胜局";
                }
            }
            return "败局";
        }
    
        //计算拈和,用集合框架最方便
        private byte[] getNimAnd(int[] heap) {
            //创建二维数组
            byte[][] allConvision = new byte[heap.length][];
            //转换二进制
            for (int i = 0; i < heap.length; i++) {
                //将转换出的二进制存储
                allConvision[i] = conversion(heap[i]);
            }
            //找出长度最长的二进制串
            int max = 0;
            for (int i = 1; i < allConvision.length; i++) {
                if (allConvision[max].length < allConvision[i].length) {
                    max = i;
                }
            }
            //求拈和
            int maxLen = allConvision[max].length - 1;
            for (int i = 0; i < allConvision.length; i++) {
                if (i != max) {
                    for (int i1 = allConvision[i].length - 1; i1 >= 0; i1--) {
                        allConvision[max][maxLen + i1 - allConvision[i].length + 1] = (byte)
                                ((allConvision[max][maxLen + i1 - allConvision[i].length + 1] + allConvision[i][i1]) % 2);
                    }
                }
            }
            //返回结果
            return allConvision[max];
        }
    
        //十进制转换二进制
        private byte[] conversion(int decimalNum) {
            byte[] result = new byte[decimalNum / 2 + 1];
            //循环取余
            int i = 0;
            while (decimalNum != 0) {
                result[result.length - 1 - i] = (byte) (decimalNum % 2);
                decimalNum >>= 1;
                i++;
            }
            return result;
        }
    
        public static void main(String[] args) {
            //创建一个数组
            System.out.println(new NimAnd().victory(new int[]{1, 2, 3, 4, 5}));
    
        }
    }
    ```
    
    




## 3.分治法

- 思想：将规模为N的问题分解为K个规模较小的子问题，**使这些子问题相互独立可分别求解**，**再将k个子问题的解合并成远问题的解**。如子问题的规模仍很大，则反复分解直到问题小到可直接求解为止。

   一句话：分而治之，然后合解为原。

  分治法有减治法之间的关系：

  Therefore, **some authors** consider that the name "divide and conquer" should be used only when each problem may generate two or more subproblems. The name decrease and conquer has been proposed instead for the single-subproblem class.

  减治法思想是逐渐减小问题规模，而小规模问题的解就是最终问题的解。这是有种代换的感觉在里面，因为往往小规模问题与大规模问题存在一种**常数**关系式。这也就是上面说的分解为一个问题，这个问题与原问题是相同的问题。

  分治法是小问题解最终合并后的解才是最终问题的解。所以可以看出分治法也是在减小规模，将大问题转换为小问题进行求解，也就是说大概率情况是这样——一个大规模问题一次性解代价大或者是无解，但是局部问题代价小或者可解，比如一个庞大的软件项目，使用功能结构分解。但是它的分解后的子问题们可能是同一类问题或者不是同一类问题，这些子问题之间的关系以及子问题与原问题之间的关系大多很复杂，将这些问题组合起来才是原问题。所以认为分治法是分解为多个问题。
  
  从这点上说：减治法有串行的感觉，分治法有并行的感觉。减治法是会尽量将没有用的输入进行逐步丢弃排除掉或是使用常量进行代替。而分治法所有输入都是要进行使用，只是分开处理。
  
- 在分治法种，子问题的解法通常与原问题相同，自然导致递归过程。（既然如此，为何不直接减治法？如果减治法的代价比较小我们可以使用。记住一句话，**一个问题的解法有多种，我们需要不断完善，尽量得到最好的算法**。）

- 不是所有的分支算法都一定比蛮力法更高效，但使用分治算法所用的时间往往比其他方法所用的时间少。

- 分治算法对于并行计算是非常理想的，因为各个问题都可以由各自的cpu同时计算。

- 分治法还能与其他方法进行组合使用，比如：我们先将一个大规模问题使用分治法进行分解，然后再使用减治法、蛮力法、分治法进行对小规模问题的求解。

- 例子：对n个数求和。

   - 可以使用蛮力法直接挨个数相加
   - 可以使用减治法将自底向上或是自顶向下（可以知道这思想的最终解法与蛮力法解法一致。因为只能进行减常量1才能求解。）
   - 使用分治法，我们可以将问题分为数一一组合，分别求解然后再次对结果组合，重复直至只剩一个元素。也可以先将其划分为两部分，再将两部分再次划分，再逐步递归。

- 分治法效率分析：

   

   
  
   
  
   - 规模为n的实例可以划分为b个规模为n/b的实例，其中a个实例需要求解（a和b是常量，a>=l,b>l）。假设n=b^k，算法运行时间为T(n),则有通用分治递推式：（a就是子问题的个数，n/b代表子问题的规模。比如n=6,分为两个子问题,a=2,b=2）(两者的区别是如果能够均分，a=b,不能a与b也近似相等。)
   
   - $$
     T(n)=aT(n/b)+f(n)\\
     f(n)是一个函数，表示问题分解为小问题和将结果合并起来所消耗的时间。于是，T(n)的增长次数取决于a,b和f(n)的增长次数
     \\从这公式我们也能看出减常量因子可以说是分治法，它只需要求解一个实例规模\\
     运行时间效率分析：要么用递推式以及通过算法的实现直接推导\\
     要么通过主定理计算：\\
     主定理：如果通用分治递推式种f(n)\inΘ(n^d),d\ge0,那么\\
     T(n)\in
     \begin{cases}
     &Θ(n^d),&a\lt b^d,\\
     &Θ(n^dlogn),&a=b^d,\\
     &Θ(n{log_b} a),&a\gt b^d,\\
     \end{cases}
     \\对于O、Ω有类似结论
     $$
     
   
- 
  
   ```java
   public class NumSum {
       //求和
       public int sum(int[] arry) {
           return sumR(arry, 0, arry.length - 1);
       }
   
       private int sumR(int[] array, int l, int r) {
           if (l == r) {
               return array[r];
           } else {
               //否则返回左右分别求和再将两者加起来
               return sumR(array, l, (l + r) / 2) + sumR(array, (l + r) / 2 + 1, r);
           }
       }
   }
   ```
   
   
   
- 
  
- 分治求和算法的时间效率分析：这里我们只是将问题划分为两个子问题，所以a=2。当然还能在子问题基础上继续划分，或者是在原基础上划分为多个子问题。不同的划分，a与 b、f(n)就不相同。
   $$
   当输入规模n=2^k时，由通用递推式，加法运算次数A(n)=2A(n/2)+1\\
   可知参数：a=2,b=2,d=0,f(n)=1\inΘ(n^0)\\
   由主定理，可得:\\
   A(n)\inΘ(n^{log_b a})=Θ(n^{log_22})=Θ(n).
   \\我们也可以直接计算出A(n/2)的效率然后直接得出。很明显这样更精确，但是也更难算。
   $$
   
- 

### 3.1合并排序（归并排序）

- [归并排序_百度百科 (baidu.com)](https://baike.baidu.com/item/归并排序/1639015?fr=aladdin)

- 问题：将n个元素排成非递减顺序。

- 算法思路：若n为1，算法终止；否则，将n个待排元素组成的数组A[0...n-1]一分为二：A[0...[n/2]-1]和A[[n/2]...n-1],并对每一个子数组分别递归排序，再将排好序的子数组合并为一个有序数组。

- 伪代码：
  - 判断输入数组的长度如果等于1直接返回如果大于1进入第二步
  - 将这个数组划分为两部分，然后将这两部分进行合并排序。在进入第三步
  - 将排好序的两个子数组合并为一个有序的数组并返回。
  
- 将两个有序数组合并为一个有序的算法：
  - 最直接想到的肯定就是使用插入的方法，依次比较两个数组中元素的大小，小先放。那么平均效率Θ（n）。
  - 能否进行优化？我还没想到。。。。。。。。。但是如果是二路归并的话，我们可以在归并时先判断前面子数组的最大值是否小于等于后面子数组的最小值，如果是就不用进行归并了。所以最好情况效率能达到Θ（n）。反过来就是逆序数组，就是最差效率。
  
- ```java
  /*
   * 归并排序、合并排序：原数组的大小如果大于1就将其划分为两部分，先使得这两部分有序，最后将两者合并为一个有序数组
   * */
  public class MergeSorted extends Sorted {
      public MergeSorted() {
      }
  
      public MergeSorted(Comparator comparator) {
          super(comparator);
      }
  
      //归并排序
      @Override
      public <T> void sorted(T[] array) {
          merge(array, 0, array.length - 1);
      }
  
      //递归具体实现
      private <T> void merge(T[] array, int l, int r) {
          if (l == r) {
              return;
          } else {
              //将其划分为两部分分别有序
              merge(array, l, (l + r) / 2);
              merge(array, (l + r) / 2 + 1, r);
              //将两者合并为有序数组
              mergeOrder(array, l, r);
          }
      }
  
      //合并数组为有序数组
      private <T> void mergeOrder(T[] array, int l, int r) {
          //先将前面部分拷贝出来，只要后面部分有一个要放必然是最前面的元素，所以不会出现越界的情况
          T[] temp = (T[]) new Object[(r + l) / 2 - l + 1];
          //循环拷贝，其实只需要修改引用就行，因为数组中存的就是引用
          for (int i = 0; i < temp.length; i++) {
              temp[i] = array[l + i];
          }
          //现在开始进行合并
          int before = 0;
          int after = (l + r) / 2 + 1;
          for (int j = l; j <= r; j++) {
              //如果前面已经比较完了就直接将后面部分拷贝
              if (before > temp.length - 1) {
                  array[j] = array[after++];
              } else if (after > r) {
                  //如果后面部分已经取完了就直接将前面剩余部分拷贝
                  array[j] = temp[before++];
              } else {
                  //如果都没有，就进行比较，谁小就放前面
                  //有传入比较器就使用比较器
                  if (comparator != null) {
                      if (comparator.compare(temp[before], array[after]) < 0) {
                          //如果前者小就放
                          array[j] = temp[before++];
                      } else {
                          array[j] = array[after++];
                      }
                  } else {
                      //没有比较器就使用该类实现的comparable接口
                      if (((Comparable<T>) temp[before]).compareTo(array[after]) < 0) {
                          //前者小就放
                          array[j] = temp[before++];
                      } else {
                          array[j] = array[after++];
                      }
                  }
              }
          }
      }
  }
  ```

- 归并排序的效率分析:

  
  
  - $$
    设n=2^k,则关键字比较次数的地推关系式为：\\
    C(n)=2C(n/2)+C_{merge}(n),C(1)=0\\
    在最差情况下（最小元素轮流来自不同的数组），\\C_{merge}(n)=n-1\\
    于是在，在最差情况下\\
    C_{worst}(n)=2C_{worst}(n/2)+n-1,C_{worst}(1)=0\\
    通过逐步代换我们可以得到如下形式的关系式：\\
    C_{worst}(n)=2(2(2(...)+n/4-1)+n/2-1)+n-1\\
    通过这个式子我们可以进行求解：\\
    将-1提出来：得到一个等比数列：共有log_2n项，公比为2.所以求和为：S1={2-2*2^{log_2n}\over-1}=2n-2\\
    再将log_2n提出来:我们可以知道每项为——2^{log_2n}*{n\over 2^{log_2n}}=n,而总共有log_2n项，所以S2=nlog_2n\\
    最终C_{worst}(n)=nlog_2n-2n+2+n-1=nlog_2n-n+1\in Θ(nlog_2n)\\
    当然我们还能通过主定理式进行求解：\\
    a=2、b=2、f(n)=n-1\\
    所以：d=1,a=b^d=b,所以：C(n)\inΘ(n^dlogn)=Θ(nlogn)
    $$
    
  
- 合并排序优缺点分析：

  - 合并排序在最查情况下的键值比较**十分接近于任何基于比较的排序算法在理论能够达到的最少次数**。
  - 合并算法具有**稳定性**，这个取决于你的合并有序数组是否进行了稳定性确定。能保证稳定性，但是你可以不保证。
  - 合并排序的主要缺点是该算法需要线性的额外空间。

- 合并排序 的两类主要变化形式：

  - 将算法使用自底向上合并数组的一个个元素对，然后再合并这些有序对，依次类推。这就避免了堆栈出来递归调用时的时间和空间开销。
    - 这个意思就是：不使用递归实现算法，而是直接将从数组元素两两组合开始合并，然后将合并的部分再两两组合再合并，直到最后合并为一个。
    
    - ```Java
      public class MergeSortedVariant extends Sorted {
          public MergeSortedVariant() {
          }
      
          public MergeSortedVariant(Comparator comparator) {
      
          }
      
          @Override
          public <T> void sorted(T[] array) {
      
          }
      
          //归并排序变体1,直接自下而上合并元素
          private <T> void variantNoRecursion(T[] array) throws IllegalAccessException, InvocationTargetException {
              //先计算合并的规模
              int size = 1;
              //一致循环直到要合并的规模等于数组的大小停止算法
              while (size < array.length) {
                  //从头部指针开始
                  int traverse = 0;
                  for (int end = traverse + (size << 1) - 1; end <= array.length - 1; ) {
                      //因为如果存在孤儿，必然每次是合并在最后一个子数组。但是我们是按照2的整数倍规模进行扩展的。
                      //所以需要看是否是最后一次合并
                      if (end + 2 == array.length) {
                          //如果是就修改end
                          end++;
                      }
                      //调用合并函数
                      mergeOrder(array, traverse, end);
                      //合并后修改要合并的边界
                      traverse = end + 1;//上次结尾下标有意一位
                      end += size << 1 ;//将上次结尾坐标移动容量的两倍，相当于traverse移动2倍size-1,因为是下标所以要减一。
                  }
                  //每扫描完一次，我们就需要更改规模
                  size <<= 1;
              }
          }
      
          //合并为有序数组
          private <T> void mergeOrder(T[] array, int l, int r) throws InvocationTargetException, IllegalAccessException {
              //通过反射调用MergeSorted中的合并有序数组的方法
              Method[] methods = MergeSorted.class.getDeclaredMethods();
              //因为是目标方法是泛型方法，无法直接通过方法名与参数类型进行获取所以只有遍历。
              for (Method method : methods) {
                  if (method.getName().equals("mergeOrder")) {
                      method.setAccessible(true);
                      method.invoke(new MergeSorted(), array, l, r);
                  }
              }
          }
      }
      ```
  - 可以把数组划分为待排序的多个部分，再对他们递归排序，最后将其合并在一起。尤其适合对存放在二级存储空间的文件进行排序，也称为多路合并排序。
    - 而这个变体的意思的是：一开始不将它分为2部分，而是多余两部分。就像减治法中假币问题一样，但是我们要适当的分要在效率的临界点进行划分最为合适。从而做到效率最大化。
    - 当数据量极大时，内存往往是不够用的，那么使用内排序往往是无法解决问题，这时候就需要借助物理磁盘存储中间结果，将物理文件中的数据读取到内存进行处理，处理后又写回磁盘中。而因为内存受限，往往一个大型的文件是无法完全读取这就需要使用分治的思想。
    - 多路归并详解：
      - [外排序－多路归并 - 简书 (jianshu.com)](https://www.jianshu.com/p/dce6a43d4678)
      - [多路归并排序 - qianye0905 - 博客园 (cnblogs.com)](https://www.cnblogs.com/qianye/archive/2012/11/25/2788231.html)
      - [(17条消息) 经典排序之多路归并_Duplan的专栏-CSDN博客_多路归并](https://blog.csdn.net/u010367506/article/details/23565421/)

### 3.2 快速排序

- 快速排序是按照数组中元素的值对它们进行划分，对给定数组中的元素进行重新排列。（快排属于交换排序，是冒泡排序的改进版）

- 快排是一种在相同规模下比较吃实际的值、划分方式、中轴选取的一种排序算法，因为每次扫描比较的次数都是n。但是因为上几种原因会让交换次数产生变化。交换次数是一个动态概念。

- [(17条消息) 排序算法---快速排序，随机快速排序和双路快排（python版）_xuewen小渣渣的博客-CSDN博客_随机快速排序](https://blog.csdn.net/m0_37519490/article/details/80648011)

- 

- 算法思路：对于数组A（从划分的角度看也能够显而易见为什么快排具有不稳定性）

  - 先划分和先前我们在中值选择问题中的概念一样：选取A中的一个元素作为分裂点或基准点（划分点、中轴），将数组A划分为3段：使得一段小于等于这个基准点的元素、一段就是基准点元素、一段大于等于这个基准点的元素。

    ![](..\图片\20211113164224.jpg)

    - 选取的这个基准点的位置在划分过程中确定，建立一个划分以后，基准点已经位于它在有序数组中的最终位置。

  - 然后递归求解：递归调用快速排序算法，对s位置前部分进行划分，以及对s位置后部分划分。当两部分都划分好了，排序也就完成了，就返回。

  - 问题：如何选取中轴元素。

    - 最简单的就是选取第一个元素。
    - **通过随机算法进行元素选取。**

  - 划分算法：

    - lomuto划分：单指针遍历算法，只记录小于段的最后一个元素的位置，小于就与大于段的起始位置进行交换，大于就直接下一个，最后将中轴元素与小于段的最后一个元素进行交换。

      ```Java
          //使用lomuto划分递归实现
          private <T> void lomutoDivision(T[] array, int l, int r) {
              //如果l>=r就直接返回,因为划分后会出现某一段没有元素的情况。
              if (l >= r) {
                  return;
              } else {
                  //否则就进行递归划分
                  int axis = lomuto(array, l, r);//第一次划分结果
                  //对小于段进行递归划分
                  lomutoDivision(array, l, axis - 1);
                  //对大于段进行递归划分
                  lomutoDivision(array, axis + 1, r);
              }
          }
      
          //使用lomuto划分进行实现
          private <T> int lomuto(T[] array, int l, int r) {
              //当只有一个元素时直接进行返回,因为外层递归已经进行判定，这里可以不用叛定。
              if (l == r) {
                  return l;
              } else {
                  //如果不是就选取左边第一个元素作为中轴然后开始划分
                  T axis = array[l];
                  //从左下标到右下标逐步开始遍历
                  int traverse = l;//记录小于段的最后一个元素，起始为空。
                  for (int i = l + 1; i <= r; i++) {
                      //判断大小
                      if (comparator != null) {
                          //下面这部分代码可以抽取出来作为一个判定结果方法，提高内聚
                          //如果比较器不为空，就使用比较进行比较
                          if (comparator.compare(axis, array[i]) > 0) {
                              //如果小于中轴，就与大于段第一个元素交换位置
                              T temp = array[++traverse];
                              array[traverse] = array[i];
                              array[i] = temp;
                              //可以通过预先判定l+1的与下标是否相等，相等就不交换，避免不必要的交换代价。还是需要根据具体的场景
                          }
                          //大于等于就不进行处理，直接洗一个元素
                      } else {
                          //没有比较器就使用自己实现的comparable接口方法进行比较
                          //结果判定与上面重复
                          if (((Comparable<T>) axis).compareTo(array[i]) > 0) {
                              T temp = array[++traverse];
                              array[traverse] = array[i];
                              array[i] = temp;
                          }
                      }
                  }
                  //遍历完成后，将中轴与小于段的最后一个元素进行交换
                  array[l] = array[traverse];
                  array[traverse] = axis;
                  //返回最终中轴下标
                  return traverse;
              }
          }
      ```

      

    - hoare（霍尔）划分：双指针遍历算法

      - 采用基于两次扫描子数组的方法对元素重新排列：一次是从左到右，另一次是从右到左，每次都把子数组的元素和中轴进行比较。
      
      - 从左到右的扫描（用索引i表示）：从第二个元素开始。--希望小于中轴的元素位于子数组的第一部分，扫描会忽略小于中轴的元素，知道遇到第一个大于等于中轴的元素才会停止。
      
      - 从右到左的扫描（用索引j表示）：从最后一个元素开始。--希望大于中轴的元素位于子数组的第二部分，扫描会忽略大于中轴的元素怒，直到遇到第一个小于等于中轴的元素才会停止。
      
      - 伪代码：
        - 索引i指向索引1，索引j指向数组末尾索引
        - 进入永真循环。
        - 循环：比较a[i]与中轴大小，直到a[i]大等于中轴；比较a[j]与中轴大小直到小于等于中轴停止；比较i与j的大小，如果i<j就交换两者元素位置且i+1,j-1，如果i>=j就直接退出循环。
        - 循环后，如果i>j交换a[j]与中轴元素。算法结束。如果i==j就交换a[j-1]与中轴。
        
      - Java代码
      
        ```java
            //使用hoare划分递归实现
            private <T> void hoareDivision(T[] array, int l, int r) {
                //如果没有元素或者元素只有一个就不用在进行划分了
                if (l >= r) {
                    return;
                } else {
                    //否则就需要将其进行划分，然后对左右子数组进行递归划分
                    int subscript = hoare(array, l, r);
                    hoareDivision(array, l, subscript - 1);
                    hoareDivision(array, subscript + 1, r);
                }
        
            }
        
            //hoare划分
            private <T> int hoare(T[] array, int l, int r) {
                if (l == r) {
                    return l;
                } else {
                    T axis = array[l];
                    int i = l + 1;//小于段的索引
                    int j = r;//大于段的索引
                    //进入循环
                    while (i < j) {
                        //i开始遍历,小于就继续循环，大于等于就结束
                        if (comparator != null) {
                            while (comparator.compare(axis, array[i]) > 0 && i <= r) {
                                i++;
                            }
                        } else {
                            while (((Comparable<T>) axis).compareTo(array[i]) > 0 && i <= r) {
                                i++;
                            }
                        }
                        //j开始遍历，大于就继续循环，小于等于就结束
                        if (comparator != null) {
                            while (comparator.compare(axis, array[j]) < 0 && j >= l + 1) {
                                j--;
                            }
                        } else {
                            while (((Comparable<T>) axis).compareTo(array[j]) < 0 && j >= l + 1) {
                                j--;
                            }
                        }
                        //比较i与j的大小
                        if (i >= j) {
                            //交换两者的位置
                            T temp = array[i];
                            array[i] = array[j];
                            array[j] = temp;
                        }
                    }
                    //退出循环后
                    if (i == j) {
                        //交换中轴与j-1
                        array[l] = array[j - 1];
                        array[j - 1] = axis;
                        return j - 1;
                    } else {
                        //交换中轴与j
                        array[l] = array[j];
                        array[j] = axis;
                        return j;
                    }
                }
            }
        ```
      
        
      
    - 两种划分比较：
    
      - 因为比较次数相同，就交换次数不同。
        - 最坏情况下：
          - 对lomuto划分：全部小于：lomuto划分，需要交换n次。hoare划分交换1次。
          - 对hoare划分：大于小于各一半，大在前，小在后：两者都只需要floor（n/2）+1次。
        - 最好情况下：
          - 对lomuto划分：全部大于：两者都不需要交换。
          - 对hoare划分：全部大于或者全部小于：全部小于时-lomuto划分需要交换n次，hoare划分不需要交换。
      
    - 关于递归方法的调用的分析：我们可以使用递归调用树进行分析：
    
      - ![](..\图片\20211114104843.jpg)
      - 上面是hoare划分，然后通过前中序遍历我们就能得到最终的排序序列。
      - 其实递归算法都能通过递归调用树进行分析。
    
  - 快排效率分析：基于hoare划分进行分析
  
    - 基本操作：比较（不包括交换）
  
    - 如果扫描指针交叉，建立划分之前所执行的键值比较次数是n+1;如果指针交叉，建立划分之前所执行的键值比较次数是n+1;如果指针指向同一元素，比较次数是n。
  
    - $$
      最优情况：所有的分裂点位于相应子数组的终点，比较次数最少，\\
      于是n>1,C_{best}(n)=2C_{best}(n/2)+n,C_{best}(1)=0\\
      那么就能通过数列计算方式计算出比较次数，从而得到效率级数。或者是通过主定理进行估算出效率：C_{best}(n)\inΘ(nlog_2n)\\
      最差情况下：所有的分裂点都趋于极端：两个子数组右一个为空，而另一个子数组仅仅比倍分区的数组少一个元素。\\
      例如严格递增的数组\\
      从减规模的角度看，也就是说，每次输入规模仅仅减小常量1。而上者是每次减少常量因子1/2。\\
      那么每次次数就形成一个大约n-1项等差数列，最少比较3次，取巧进行求和n+1项减3，\\
      所以求和得到估摸就是：（n+2)(n+1)/2-3等价于(n-1)(n+4)/2,所以最差效率C_{worst}\in Θ(n^2)
      $$
  
- 



### 3.3 大整数乘法与Strassen矩阵乘法

- 简介：两个极大数的乘法和两个方阵的乘法；两个算法试图以增加少量加法运算为代价，减少乘法运算的执行总次数。
- 想想整数乘法规则，一个数的低位开始逐渐与另一个数的从低位开始相乘得到一个数，然后将这些数加起来就是乘法。总共要执行的乘法的次数就是m×n（m、n分别是两个数的位数），而加法次数就是{m×n}+n（注意：m与n可以互换）
- 想想矩阵的乘法规则：假设m×n与n×k行相乘。那么得到的是m×k的矩阵。每次前矩阵的第i行与后矩阵的第j列进行相乘，然后相加得到第i、j位置的元素。那么分析乘法次数：就是n×k×m次。而加法需要执行的次数就是n×k×m次。
- 可见上面使用传统的蛮力思想整数的效率是O(n^2);矩阵的效率是O(n^3)。
- 为什么乘法、除法效率低这就需要去看计算机的机内实现了，反正很复杂。计算机组成原理中：乘法、除法、取余等等。

#### 3.3.1大整数乘法

- Java中大整数乘法实现指的参考：一是直接相乘，效率O(n^2)。二是使用Karatsuba。三是使用toom-cook算法。BigInteger的实现思路值得学习，特别是它的存储大数的思想，高效且使得操作便捷。
  - [(21条消息) 大整数乘法中的分治思想（TOOM-COOK的一种使用方法）_scot的博客-CSDN博客_在用分治法求两个n位大整数u和v的乘积时](https://blog.csdn.net/wwtwinter/article/details/82878132)
  - **[Java大数源码剖析(一) - BigInteger的底层数据结构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/390067069)**
  - [java的BigInteger的乘法运算是用什么算法实现的？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/36725424)
  - [(21条消息) biginteger 原理_java BigInteger源码学习_独狼苏的博客-CSDN博客](https://blog.csdn.net/weixin_36296215/article/details/111968236)
  - [大整数乘法中的分治思想（TOOM-COOK的一种使用方法）_scot的博客-CSDN博客_在用分治法求两个n位大整数u和v的乘积时](https://blog.csdn.net/wwtwinter/article/details/82878132)
  
- 大整数乘法有一般采用三种算法 ：

    - 朴素乘法（小学生乘法）:就是传统的竖式乘法
    - karatsuba
    - toom-cook
    - [计算二进制数中1的个数_方问楚的博客-CSDN博客](https://blog.csdn.net/weixin_43036882/article/details/105980095)

- 现实需求：如密码技术，需要对超过100位的十进制整数（10^100≈1/8 TB的大小）进行乘法运算，这种长度的整数现代计算机的一个基本类型是装不下的，想想我电脑现在内存也不过才8G，因此需要对这种整数利用分治技术来做特别的处理。

- 比如我们在多路归并中的思想将其分割，然后分别计算，使用外存进行中间结果存储，最后进行统一合并处理。

- 设AB为两个n位（n为偶数）的大整数。直接计算相乘需要执行n^2次1一位数乘n位数的乘法。

- 分治解法思路：（这是当n是一个偶数时才采用）

    - 利用分治技术从中间把两个数字一分为二，A的前、后半部分分别记为a1、a2，B的前后半部分分别记为b1、b2，则
      $$
      A=a_1a_2=a_110^{n/2}+a_2\\
      B=b_1b_2=b_110^{n/2}+b_2\\
      则：\\
      A*B=(a_110^{n/2}+a_2)*(b_110^{n/2}+b_2)\\
         =a_1*b_110^n+(a_1*b_2+a_2*b_1)10^{n/2}+a_2*b_2\\
         =a_1*b_110^n+[(a_1+a_2)*(b_1+b_2)-a_1*b_1-a_2*b_2)]10^{n/2}+a_2*b_2\\
         由这个式子我们可知进行一次将乘法次数进行减一，而加法次数加一、减法次数加二。
      $$
      
    - 

    

- 效率分析：
    $$
    基本操作：乘法、加减法\\
    记M(n)为计算两个n位整数相乘所需乘法次数。则M(n)=3M(n/2),M(1)=1\\
    令n=2^k，利用反向替换法，易得M(n)=3^{log_2n}=n^{log_23}\in Θ(n^{log_23})≈Θ(n^{1.58})\\
    如何证明：3^{log_2n}=n^{log_23}\\
    通过换地公式，目标是将3去掉，那么将指数log_2n换成log_3n,就构造log_{2^{log_23}}n,然后为了保证指数不变，\\
    指数整体构造就是log_{2^{log_23}}n^{log_23}--因为底数与真数的指数能够提前。\\
    所以最终指数：log_3n^{log_23}。故上面的式子得证。\\
    可见乘法效率有改善\\
    记C(n)为计算两个位整数相乘所需的加减运算次数，则：\\
    C(n)=3C(n/2)+k*n，C(1)=1--这个还是看具体实现，其实还能是0，2，k为常数。\\
    解得：C(n)=n^{log_23}+2kn^{log_23}-2k\in Θ(n^{log_23})≈Θ(n^{1.58})\\
    可见加减法次数也是得到提升\\
    通过找规律得到一个等比数列，然后进行求和，即可得到\\
    综上：加减法次数、乘法次数具有都提升且具有相同级数。
    \\同样这些效率可以主定理式进行直接求解。
  $$
  
- 问题1：

    - 乘10的n次方如何解决？这不是添加了乘法的次数吗？
    
- 通过汇编的思想能够解决，只要每次乘8（左移3位），然后两次加上本身就能达到乘10的目的。（如3*10=3×8+3+3=30）
    - [用移位指令实现al乘10（带进位）_X-jazz的博客-CSDN博客](https://blog.csdn.net/qq_43071318/article/details/105170485)
    - [用移位指令实现al乘10（不带进位）_X-jazz的博客-CSDN博客](https://blog.csdn.net/qq_43071318/article/details/105170067?ops_request_misc=&request_id=&biz_id=102&utm_term=使用移位实现除10&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-105170067.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187)
    - 那么除法又该如何解决？可以使用欧几里得公式n=qa+r,除法转换为乘法，然后使用循环验证的方式进行求q。或者使用转换为循环做，减法和右移操作进行解决，所以除法与取余的操作往往最耗时。
    - 我们还能够通过转换为对数域的运算，将乘除法转换为加减法，然后通过移位操作反向转换为最终结果。
    
- 问题2：[整数的故事(4)——Karastuba算法_weixin_30813225的博客-CSDN博客](https://blog.csdn.net/weixin_30813225/article/details/98276829)

    - 两个大数的位数不同怎么办，这还能使用karatusba吗？
    - 能，套公式嘛？主要就是乘10的位数不同而已。比如n位与m位，那么10的位数应该是:n+m/2。

- 问题3：能否通过划分为多份来提升效率？

    - [2020-03-03 p3 算法_分治_整数乘法_矩阵乘法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1q7411X7fG?from=search&seid=1801812403630800632&spm_id_from=333.337.0.0)

    - 按理说是能够的，也就是存在一个分解为多份之后，新的表达方式能够减少乘法的次数。

    - 实际数学推理得到规律如下：

    - 
      
      $$
      a=份数，b=乘法次数，b=2a-1\\
      那么我们分治法基本运算次数,通过等比数列的求和公式可得：\\
      T(n)=bT(n/a)+O(n)\\
      	=n^{log_ab}+O(n)\\
      则有：\\
      a=2,b=3||||
      T(n)=n^{1.59}\\
      a=3,b=5||||
      T(n)=n^{1.465}\\
      a=4,b=7||||
      T(n)=n^{1.404}\\
      a=5,b=9||||
      T(n)=n^{1.365}\\
      可见如果段数增加，那么复杂度是在降低的。\\
      那么是否会有分段的下限，目前为止通过FFT-快速傅里叶变思想，以n/logn进行划分，\\
      得到效率为为O(nlogn).但是下限是不确定的，因为FFT在实数范围内是存在Ω(n)的情况\\
      但是我们知道前提是存在将原来的计算方式转换为等价的减少方式
      $$
      
      

- 如果n是奇数那么划分时可以是floor(n/2)或者ceil(n/2),**而此时10的指数就是低位的位数**。

- 注意：如果存在分治算法性能超越传统算法得“转折点”，当倍乘数位数小于转折点时，改用传统算法继续计算。（其实很多算法都是这样，都存在一个转折点，，但是转折点往往是动态的，这需要大量的实际数据进行测试得出。）

- 在理论上，计算8位十进制数乘法时，分治算法速度快于传统方法，计算300位以上十进制数乘法时，分治算法速度是传统算法的两倍多。

- 究竟采用哪种算法这是需要考虑很多条件的，比如硬件环境，编程语言，（这很可能导致同种算法效率产生较大差异）实现成本等等。

#### 3.3.2 Strassen矩阵乘法

- $$
  若矩阵A、B是2个n×n的矩阵，则它们的乘积C=A×B同样是一个n×n的矩阵：\\
  c[i,j]=\sum_{k=1}^nA[i,k]B[k,j]\\
  每计算C的一个元素C[i,j],需要做n个乘法和n-1次加法。这样，求出矩阵C的n^2元素所需的计算时间为Θ(n^3)\\
  假设n=2^k,将n阶方阵A、B和C(如果n不是2的乘方，矩阵可以用-的列或行来填充)中每一矩阵都分块成为4个大小相等的子矩阵，\\
  每个子矩阵都是n/2乘n/2的方阵。
  $$

- 简单点说：将大矩阵分为小矩阵然后进行乘积运算，但是仅仅只是进行分割运算是无法进行乘法次数减少的，所以我们需要找到一个公式减少乘法的次数。从而达到提高效率的目的。

- 现在我们就描述下使用分治法将大矩阵进行两份分割转换的公式：
  $$
  Brute Force:C[i][j]=\sum_{k=1}^nA[i][k]×B[k][j]\\
  现在有如下矩阵乘积：\\
  \begin{bmatrix}
  C_11&C_12\\
  \hline
  C_21&C_22\\
  \end{bmatrix}
  =
  \begin{bmatrix}
  A_11&A_12\\
  \hline
  A_21&A_22\\
  \end{bmatrix}
  ×
  \begin{bmatrix}
  B_11&B_12\\
  \hline
  B_21&B_22\\
  \end{bmatrix}
  \\
  我们将AB分解为四个子部分，然后两两相乘，很明显这样做并不会减少乘法的次数。\\
  假设两个矩阵现在是2×2.那么使用划分之后的计算次数仍然是8次乘法。\\
  所以我们的需要进行转换计算方式达到减少的乘法次数\\
  $$
  <img src="C:\Users\胡远灵\Desktop\知识总结\算法与数据结构\图片\20211207203516.jpg" style="zoom:67%;" />

- 可见将矩阵按两段进行分解，最终能够将8次乘法转换为7次乘法以及18次加法。所以一次乘法真的比18加法要慢吗？
- 当然如果要进一步提升效率，就可以进行多部分划分比如按三段分解等等，但是我们需要找到最终的转换公式。所以这时候就知道各种转换公式的重要性了，比如傅里叶变换、欧拉公式、拉格朗日变换、泰勒公式等等。
- 那么这个分治法，目前为止效率区间：O(n^2.373),下界是Ω(n^2)。

### 3.4 分治法解决最近对与凸包问题

- 分治法解决最近对

  - 伪代码

    ```tex
    n较小时直接求（n=2）
    将S上的n个点分成大致相等的2个自己S1以及S2（怎么分，按照x的中位数来分，所以就需要先进行排序）
    分别求S1和S2中的最近对
    求一点在S1、另一点在S2中的最近对
    找出三者中最短的值就是结果
    -------------------------------------------
    分析下效率：
    我们记每次求点对的基本操作为w
    那么：
    由蛮力法我们知道计算次数为：n(n-1)/2
    分治法的主定理式，我们知道：分治的主要效率取决于a,b^d的大小，而a=2，b=2已经确定，所以效率往往最终的级数往往就是取决于合并算法的复杂度级数，如果我们使用蛮力法，显然合并算法的级数是Θ(n^2)。那么整体效率就是Θ(n^2)，如果合并效率能到线性级或是常数级，那么整体效率就是Θ(nlogn)
    --------------------------------------------
    是否能够找到线性级或者常数级的合并算法？（使用减治法地思想，尽量减少要解决地规模，去除不必要的验证）
    能够。我们先将点集进行按照x排序，然后按照y进行排序。然后按照x的中位数m进行划分两个子集。通过分治计算出两子集的最近对d1,d2。令d{min d1,d2}那么进行合并时，我们知道一个点在S1，一个点在S2，所以是分居在中位线的两侧（同侧已经验证了），所以如果两个点的横坐标差值如果大于d那么必然不会是最近对。所以在中位线的左右d范围之外的点并不需要进行验证。同理，我们可以对y进行区域划分，在x在m-d<=m<=m+d范围内的一边进行选取一个点（x,y），然后在另一个范围进行划分0<y-d<y<y+d.我们只需要验证这个范围内的点的距离是否小于d，且这样的点不会超过6个。为什么？将这个区间横向划分为3等分，再将其纵向划分为两份，那么我们就得到6个宽为2d/3且长为d/2的矩形，假设有超过6个点，那么必然有个矩形有超过两个点（鸽笼原理），那么我们知道矩形内最长距离是对角线5d/6<d,所以与初始条件矛盾，所以必然不会超过6个。原理就是通过划分矩形确定最小值的边界。
    这样的效率是多少，左右所有点总共肯定<n，每次计算次数6，所以θ(n)
    ---------------------------------------------
    能否只验证离m最近的点，不能，因为x,y的值具有不确定性，无法保证一定存在，也无法保证其他情况不存在。
    --------------------------------------------
    可以想想为什么能够将复杂度降阶，它减少的部分究竟是哪里？
    很明显每个子部分我们都需要进行验证，但是子集的组合验证进行大量的减少。而因为不断地分割，其实最终我们进行子部分地验证的次数少之又少（从递归的角度我们知道，只有遇见递归的返回条件时，才进行了一次子部分的计算并返回，往后返回的都是直接归并的结果），所以主要就是在进行合并。而合并是在一定的范围内具有确定的点数，那么也就是常量级的。所以也就是为何分治效率往往取决于合并。
    ---------------------------------------------
    分治解决最近对问题的美感：
    如果将所有点集连接起来，我们就是在不断的建造离散型的分割线，然后进行验证。
    ---------------------------------------------
    能否通过合并划分的思路进行对蛮力法的优化？
    如果在已知d的情况下可以。
    如果在不知而是要求d_min的情况下，可以先计算一个d然后进行划分，然后不断地更新d,这是采用减治法地思想。
    ```
    
    ```java
    /*
     * 利用分治法解决最近点对问题
     * 输入一个点集，进行排序，排序规则:先按照x进行排序，再按照y进行排序。
     * 然后找到中位数，将其划分为两个部分。
     * 分别求解，然后合并。
     * */
    public class RecentlyPoint {
        //点集
        private Point[] points;
        //结果所有的最近对
        List<List<Point>> result = new ArrayList<List<Point>>();
        //最近对的距离
        double distance;
    
        public RecentlyPoint() {
        }
    
        //寻找最近点对,返回一个点对数组
        public Map<List<List<Point>>, Integer> getRecentlyPoints(Point[] parameter) {
            //初始化
            points = parameter;
            //排序，先进行归并排序
            sorted();
            distance = recursion(0, points.length - 1);
            Map map = new HashMap<>();
            map.put(result, distance);
            return map;
        }
    
        //递归求解最近对
        private double recursion(int l, int r) {
            //先确定需要求解的长度
            if (r - l < 3) {
                //如果元素小于4个就直接使用蛮力法求解
                return bruteForce(l, r);
            } else {
                //分割
                double d1 = recursion(l, (l + r) / 2);
                double d2 = recursion((l + r) / 2, r);
                //比较获取最小值
                double d_min = (d1 > d2) ? d2 : d1;
                //调用最近对合并算法
                double d3 = mergeRecent(l, r, d_min);
                //返回最小值
                return (d3 > d_min) ? d_min : d3;
            }
    
        }
    
        //合并最近对
        private double mergeRecent(int l, int r, double d_min) {
            //根据左右边界计算中位数
            double median;
            if ((r - l + 1) % 2 == 0) {
                //如果是偶数个,就取中间两个数的平均值
                median = (points[(l + r) / 2].x + points[(l + r) / 2 + 1].x) / 2;
            } else {
                //如果是奇数个,就取中间单个数的平均值
                median = points[(l + r) / 2].x;
            }
            //先确定左右垂直子集的边界，如果最终没有找到这样的数值，我们就直接指定边界
            int c1 = l;
            int c2 = r;
            for (int i = (r + l) / 2; i >= l; i--) {
                if (Math.abs(points[i].x - median) > d_min) {
                    c1 = i + 1;
                    break;
                }
            }
            for (int i = (r + l) / 2 + 1; i <= r; i++) {
                if (Math.abs(points[i].x - median) > d_min) {
                    c2 = i - 1;
                    break;
                }
            }
            //如果最终的确定的边界有一边为空集，就直接返回d_min
            if ((c1 == (r + l) / 2 + 1) || (c2 == (r + l) / 2)) {
                return d_min;
            }
            //否则我们就需要就对两个子集进行遍历
            //先遍历c1
            double d = d_min;
            for (int i = c1; i <= (l + r) / 2; i++) {
                for (int j = (l + r) / 2 + 1; j <= c2; j++) {
                    //确定当前点的y的范围
                    if (Math.abs(points[i].y - points[j].y) <= d) {
                        d = checkSub(i, j, d);
                    }
                }
            }
            //遍历c2
            for (int i = (l + r) / 2 + 1; i <= c2; i++) {
                for (int j = c1; j <= (l + r) / 2; j++) {
                    //确定当前点的y的范围
                    if (Math.abs(points[i].y - points[j].y) <= d) {
                        d = checkSub(i, j, d);
                    }
                }
            }
            //返回d
            return d;
        }
    
        //分别验证子集
        private double checkSub(int i, int j, double d) {
            double x_sub = points[i].x - points[j].x;//横坐标之差
            double y_sub = points[i].y - points[j].y;//纵坐标之差
            double temp = Math.sqrt(x_sub * x_sub + y_sub * y_sub);
            if (d > temp) {
                clearly();
                addPoints(i, j);
                return temp;
            } else if (d == temp) {
                addPoints(i, j);
            }
            return d;
        }
    
    
        //清空结果集
        private void clearly() {
            for (int k = 0; k < result.size(); k++) {
                result.remove(0);
            }
        }
    
        //添加点对
        private void addPoints(int i, int j) {
            List<Point> pointList = new ArrayList<Point>();
            pointList.add(points[i]);
            pointList.add(points[j]);
            result.add(pointList);
        }
    
        //蛮力法求解
        private double bruteForce(int l, int r) {
            //最近对的距离
            double d_min = 0XFFFF;
            //因为有序所以直接双重遍历
            for (int i = l; i < r; i++) {
                for (int j = i + 1; j <= r; j++) {
                    double x_sub = points[i].x - points[j].x;//横坐标之差
                    double y_sub = points[i].y - points[j].y;//纵坐标之差
                    double d = Math.sqrt(x_sub * x_sub + y_sub * y_sub);
                    if (d < d_min) {
                        d_min = d;
                        //如果当前的值是最小的，就将原来的点对清除并插入新的点对
                        clearly();
                        addPoints(i, j);
                    } else if (d == d_min) {
                        //如果这个距离与最小点对相等就插入这个点对
                        addPoints(i, j);
                    }
                }
            }
            return d_min;
        }
    
    
        //排序
        private void sorted() {
            if (points == null) {
                return;
            }
            //调用递归归并实现
            merge(0, points.length - 1);
        }
    
        //递归归并,lr指的是下标
        private void merge(int l, int r) {
            //如果两者只有一个元素直接返回
            if (l == r) {
                return;
            } else {
                //如果有多个元素就分割
                merge(l, (l + r) / 2);
                merge((l + r) / 2 + 1, r);
                //然后进行合并
                mergeOrder(l, r);
            }
        }
    
        //合并算法
        private void mergeOrder(int l, int r) {
            int m = (l + r) / 2;
            //将前部分拷贝出来
            Point[] tempPoints = new Point[m - l + 1];
            for (int i = 0; i < tempPoints.length; i++) {
                tempPoints[i] = points[l + i];
            }
            //确定两个遍历索引
            int p1 = m + 1;
            int p2 = 0;
            //开始循环,从左端扫描到右端
            for (int i = l; i <= r; i++) {
                //如果任意一部分到了末尾，另一部分还没完，我们都可以直接将另一部分后续拷贝完
                if (p1 > r) {
                    //将另一部分剩余拷贝
                    points[i] = tempPoints[p2++];
                } else if (p2 == tempPoints.length) {
                    points[i] = points[p1++];
                } else {
                    //如果两者没有到末尾，就进行比较
                    if (points[p1].x > tempPoints[p2].x) {
                        //将x小的放在前面
                        points[i] = tempPoints[p2++];
                    } else if (points[p1].x == tempPoints[p2].x) {
                        //如果相等就比较y,y小的放前面
                        if (points[p1].y < tempPoints[p2].y) {
                            points[i] = points[p1++];
                        } else {
                            points[i] = tempPoints[p2++];
                        }
                    } else {
                        points[i] = points[p1++];
                    }
                }
            }
        }
    }
    
    class Point {
        public double x;
        public double y;
    
        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
    //这个算法是找出所有的最近点对，但是由于我们最终是会在左右两部分进行验证，所以会进行重复验证，我们还需要想办法避免重复验证，可以采用标识的方法，或者是对最终结果进行去重，可以使用并查集的方式。
    ```
    
    

- 分治法解决凸包问题
  - [分治法在求解凸包问题中的应用（JAVA）--快包算法_一串代码的博客-CSDN博客_快包算法java](https://blog.csdn.net/qq_39630587/article/details/79264119)

  - [【算法】凸包问题--分治法 - musecho - 博客园 (cnblogs.com)](https://www.cnblogs.com/musecho/p/11703227.html)

  - [凸包问题_Gramham算法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TJ411B7tY?from=search&seid=12046217817004796162&spm_id_from=333.337.0.0)
  
  - [凸包 Gramham 扫描法_weixin_30929011的博客-CSDN博客](https://blog.csdn.net/weixin_30929011/article/details/98310460)
  
  - [凸包算法（Graham扫描法）_よろしくお願いします-CSDN博客_graham算法](https://blog.csdn.net/qq_39826163/article/details/83861353)
  
  - 这个gramham算法挺巧妙的，没有使用分治的思想保证有序情况下，最差应该是n^2。平均能够达到线性效率。（它的思想就是将参照点以及夹角排序后的第一个点除外的点放入栈中，不断地验证当前这条边是不是最外的边，如果下一个顶点进行验证时，发生了外旋，那么就立即回退-这个回退过程使用一个单独的栈进行验证。）
  
  - 求能够完全包含平面上n个给定点的凸多边形的分治算法，称为快包。
  
  - 我们知道给定一个点集，那么这个点集的凸包一定是以该点集中的某些点为顶点的凸多边形。
  
  - 现在我们进行如下操作：
    - 设P1(x1,y1)...........是平面上n个点构成的集合S
    - 假设S中的点按照x轴坐标升序排列，若x坐标相同，则按y轴坐标的升序排列。
    - 显然，位于x,y轴的极值的点必然是凸包的顶点。（比如最右边，最左边，最上边，最下边）
    
  - 设P1Pn向量是方向从点P1到点Pn，经过P1和Pn的直线，把S中的点分为两个集合：S1是位于直线左侧或在直线上的点构成的集合；S2是位于直线右侧或在直线上的点构成的集合。
  
    ![](..\图片\20211210100011.jpg)
  
  - 整个集合S的凸包是由上报和下包构成的，它们可以用同样的方法分别构造
  
  - 快包算法构造上包：
  
    - 如果S1为空，上包就是以P1Pn为端点的线段
    - 如果S1非空，找到S1中的顶点Pmax,它是距离P1Pn最远的点。如果做两条连接线的话，这个点确定了面积最大的▲PmaxP1Pn
    - <img src="..\图片\20211210101551.jpg" style="zoom:67%;" />
    - 大致的筛选过程如下：
    - <img src="..\图片\20211210104348.jpg" style="zoom: 67%;" />
    - 先选出P1Pn,然后逐步验证上包与下包中的点，，我们知道在三角形中的点是不需要验证的，我们是否可以给定一个需要验证的标识进行确定是否需要验证？不行，不能简单的通过一个访问标识确定是否还需要计算。但是从图中可以发现有些点是会进行重复验证的，能否不重复验证这些点？不能，因为这是一个动态过程我们不能预先知道这个点会不会进行验证，我们是进行遍历验证。
    - 所以有两种方式进行求解：
      - 一是每次指定一条边，以及要验证的是左还是右。然后遍历计算所有的点，找出符合条件的三角形面积最大的点。那么可以知道每给定一个非p1、pn的顶点我们就需要遍历2n次。假定凸包顶点有m个（n>m>2），那么遍历次数：2n(m-1)次。可见只要顶点数目越少那么效率就属于线性。
      - 第二种方式，在分治法思想中穿插减治法的思想：我们每给定一条分割线就先确定它的上包或者下包，然后将其拷贝到单独的数组中，下次遍历时我们就不用全部都进行计算，这样就排除了三角形内部的点。但是如果使用递归实现就需要大量的内存空间。效率还是属于线性，仅仅只是降低了线性的系数。
  
  - 我们知道通过求三角形的面积可以来确定顶点，是否由简单的求解三角形面积的方法？
  
    - 有。实现快包算法的几何操作。
  
    - 如果n1(x1,y1),n2(x2,y2),n3(x3,y3)是平面上任意三个点，那么由着三个点组成的三角形的面积等于下面行列式绝对值的1/2
  
    - 
      $$
      \begin{vmatrix}
      &x1&y1&1\\
      &x2&y2&1\\
      &x3&y3&1\\
      \end{vmatrix}
      =x1y2+x2y3+x3y1-x3y2-x2y1-x1y3
      $$
      
      
      
    - 当三者共线时，结果为0
  
    - 当且仅当n3(x3,y3)位于直线q1q2是左侧时，该表达式的符号为正。（这个条件经过验证是有问题的，如[0,1],[1,0],[1,1]，结果为1大于0，明显不符合，至少我不能理解）
  
    - 所以我更愿意用定义的判定，假设向量p1pn，通过逆时针旋转到p3那么这个叉积为正，如果通过顺时针旋转到p3结果为负。（旋转以最小角度旋转）
  
    - 利用该公式可以在常数时间内，检查一个点是否位于两个点确定的直线的左侧，并且可以求得这个到该直线的距离。
  
    - 但是如何排除在这个三角形内部的点？我们没有办法直接知道所以还是需要进行计算判断。因为我们点是有序的，当我们确定了顶点，那么就确定了点的下标的位置，那么在该点之前的点都是上包
  
  - 效率分析：
  
    - 最差效率Θ(n^2)
    - 平均效率：若给定的点是均衡分布在某些区域（如圆或长方形）内，平均效率是线性的。
  
  - 伪代码
  
    - 找到左右最边界的点,得到l,r
    - 调用递归函数遍历点集，递归找到该点集的上包。
    - 调用递归函数遍历点集，递归找到该点集的下包。
    - （注意：找上下包的递归函数的主要逻辑：一是划分子集，而是找到面积最大的顶点并加入到结果集中。递归结束的标识是当子集中没有元素时结束。判断是否符合要求的条件是：通过行列式进行计算，看是顺时针还是逆时针进行旋转。）
    
  - 
  
    ```java
    /*
     * 使用分治法求解凸包问题
     * 思路：
     * 给定一个分界向量，给定一个除分界向量端点外的点集，再给定点集位的位置应该是由分界向量顺时针旋转还是逆时针旋转。
     * （按照分治法的思想我们需要区分上下包，然后进行递归求解，
     *   但是计算结果的符号只能区分这个点分界向量顺时针旋转还是逆时针旋转，
     *   上下包递归求解过程中，点集所处的位置都有可能是分界向量顺时针旋转也可能是逆时针旋转。
     *   所以使用上下包并不能完全区分，所以用分界向量顺时针旋转与逆时针旋转进行区分。
     *   ）
     * */
    public class ConvexHull {
        //点集
        private Point[] points;
    
        //结果集
        private ArrayList<Point> result = new ArrayList<>();
    
        public Point[] getCOnvexHull(Point[] parameter) {
            points = parameter;
            //调用凸包求解逻辑
            findConvexhull();
            if (result.size() == 0) {
                return null;
            }
            Point[] ps = new Point[result.size()];
            for (int i = 0; i < ps.length; i++) {
                ps[i] = result.get(i);
            }
            return ps;
        }
    
        //实际找寻凸包逻辑
        private void findConvexhull() {
            //找寻最边界的两个点
            Point l = findBorder(true);
            Point r = findBorder(false);
            result.add(l);
            result.add(r);
            ArrayList<Point> arrayList = new ArrayList<>();
            for (int i = 1; i < points.length - 1; i++) {
                arrayList.add(points[i]);
            }
            //递归求解一次左边
            recursionHull(arrayList, l, r, (byte) 1);
            //递归求解一次右边
            recursionHull(arrayList, l, r, (byte) -1);
        }
    
        //寻找边界,左或者右,true左，false右
        private Point findBorder(boolean flag) {
            Point point = points[0];
            for (int i = 1; i < points.length; i++) {
                if (flag) {
                    if (point.x > points[i].x) {
                        point = points[i];
                    } else if (point.x == points[i].x) {
                        if (point.y > points[i].y) {
                            point = points[i];
                        }
                    }
                } else {
                    if (point.x < points[i].x) {
                        point = points[i];
                    } else if (point.x == points[i].x) {
                        if (point.y > points[i].y) {
                            point = points[i];
                        }
                    }
                }
            }
            return point;
        }
    
        //递归求解
        private void recursionHull(ArrayList<Point> points, Point l, Point r, byte uord) {
            //如果点集个数为0就直接退出,主要是针对第一次进入的时候，因为后面的情况是不会将共线点放入的并且会预先判定是否有点集才进入递归
            if (points.size() < 1) {
                return;
            }
            //否则就遍历点集，确定最大值的过程中并且将该集合按左右需要进行分割
            Point pointMax = null;//面积最大的点
            double disMax = -1;//面积最大值，注意面积我们存的是正值
            ArrayList<Point> subSet = new ArrayList<>();//子集
            //uord,1,代表逆时针旋转，-1代表顺时针旋转
            for (int i = 0; i < points.size(); i++) {
                double x1y2 = l.x * r.y;
                double x2y3 = r.x * points.get(i).y;
                double x3y1 = points.get(i).x * l.y;
                double x3y2 = points.get(i).x * r.y;
                double x2y1 = r.x * l.y;
                double x1y3 = l.x * points.get(i).y;
                double sum = x1y2 + x2y3 + x3y1 - x3y2 - x2y1 - x1y3;
                if (sum * uord > 0) {
                    //确定当前点是不是最大值点，如果这个点的值与最大值相等，随便选谁结果都一样所以不需要去找什么角度小的。
                    if (sum * uord > disMax) {
                        pointMax = points.get(i);
                        disMax = sum * uord;
                    }
                    //所以只要如果两者同号就说明是要的验证的点，将它加入子集。只有等于0的抛弃。
                    subSet.add(points.get(i));
                }
            }
            //假如子集全部验证了一遍，但是都没有找到最大值（按理说符合条件的子集也应该为空），那么就直接返回
            if (pointMax == null) {
                return;
            }
            //循环结束先从子集中将最大值顶点删除
            subSet.remove(pointMax);
            //将最大值点加入凸包
            result.add(pointMax);
            //之后进行递归求解
            //确定是求解上包还是下包
            if (uord > 0) {
                //如果是求上包就递归求上包
                recursionHull(subSet, l, pointMax, (byte) 1);
                recursionHull(subSet, pointMax, r, (byte) 1);
            } else {
                //否则就递归求下包
                recursionHull(subSet, l, pointMax, (byte) -1);
                recursionHull(subSet, pointMax, r, (byte) -1);
            }
    
        }
    }
    ```
  
- Graham算法求解凸包：

  - 既然都到了凸包就要将凸包的常用算法了解下。

  - Graham算法实现逻辑如下：

    - 选取点集中最下且最左的点作为起始参照点。

    - 将其他点按照与参照点之间极角大小进行排序。（所以我们必须要去计算极角吗？不是，请看下图）

      <img src="..\图片\20211213101942.jpg" style="zoom: 67%;" />

      - 通过这张图我们能够发现一个规律那就是，在与参照点不共线的情况下，如果一个点x越小那么相对于参照点的极角就越大，如果x相同那么y值越大极角就越大。（因为前提是我们选取的参照点是最下最左的点）所以我们可以省去计算极角。（因为计算极角我们需要先计算一次两点的y值之差，再计算一次x之差，最后还需要进行一次除法运算。还需要对最终的结果进行排序，很明显是没有直接进行2到3次逻辑判断来的简便的。）
      - 但是这样我们就无法将共线点排除掉，如果存在共线的点，且中间还穿插入一个极角小的点，那么是不正确的。所以只使用上面的条件进行判定是不正确的。是否有两全其美的方法。
      - 如果我们先将共线点删除掉，会花费多大的代价？很明显会花费6次乘法3加法，3减法基本运算的O(n^2)的代价。而直接计算极角，属于O(nlogn+n)=O(anlogn)。两者差异取决于底数。

    - 所以将点集按极角进行升序排列

    - 创建栈1（建议实现的时候不要使用纯粹栈的思想进行实现，因为我们需要不断地访问栈最顶上的的两个元素），将必然是凸包顶点的参照点以及升序点集的第一个点入栈。

    - 开始从点集列表的第二个位置开始循环

    - 访问栈顶头两个元素，构造向量P顶2P顶1。

    - 计算该向量到此时访问的点是外旋还是内旋（也就是顺时针旋转还是逆时针旋转）

      - 如果内旋，就将这个点入栈，然后开始访问下一个点集，继续循环。
      - 如果是外旋或者是共线的情况，就将栈顶元素出栈，且继续下次访问的元素仍然是当前这个点。
    
    - 循环结束，算法结束（最后一个点必然是凸包顶点，但是我们还是需要计算，因为很可能需要进行验证然后回退。）
    
    - 建议网上看动图
    
    - <img src="..\图片\20211214101223.jpg" style="zoom: 67%;" />
    
    - ```java
      /*
       * 使用graham算法解决凸包问题，这个代码值得一看，比伪代码思维上多些细节。
       * */
      public class Graham {
          //凸包
          public ArrayList<Point> getConvexhull(Point[] points) {
              //寻找最下最左边界的点作为参照点
              Point referenceP = findReference(points);
              //将剩余的点按照极角进行排序
              ArrayList<Point> pointSet = polarAngleSorted(referenceP, points);
              //调用找寻凸包逻辑
              return convexhull(referenceP, pointSet);
          }
      
          //计算凸包
          private ArrayList<Point> convexhull(Point re, ArrayList<Point> pointSet) {
              //准备一个栈
              ArrayList<Point> stack = new ArrayList<>();
              stack.add(re);
              stack.add(pointSet.get(0));
              int i = 1;//遍历索引
              while (i < pointSet.size()) {//虽然最后一个元素必然是凸包顶点，但是很可能发生回退，所以还是需要它进行验证。
                  //取出栈顶两个元素
                  Point p1 = stack.get(stack.size() - 2);
                  Point p2 = stack.get(stack.size() - 1);
                  double x1y2 = p1.x * p2.y;
                  double x2y3 = p2.x * pointSet.get(i).y;
                  double x3y1 = pointSet.get(i).x * p1.y;
                  double x3y2 = pointSet.get(i).x * p2.y;
                  double x2y1 = p2.x * p1.y;
                  double x1y3 = p1.x * pointSet.get(i).y;
                  double sum = x1y2 + x2y3 + x3y1 - x3y2 - x2y1 - x1y3;
                  //判断sum的值,逆转为正，顺转为负，外转为顺，内转为逆
                  if (sum > 0) {//如果内转就假如栈
                      stack.add(pointSet.get(i++));
                  } else {//如果外转包括0就将栈顶元素移除
                      //考虑到共线的特殊情况，因为我们排序时没有删除中间的共线点。我们这里就特殊处理下
                      if (sum == 0) {//如果共线那么必然中间的点不是凸包顶点
                          stack.remove(stack.size() - 1);//移除
                          stack.add(pointSet.get(i++));//并且将这个点加入栈中
                          //如果不进行特殊处理，很可能出现一开始就共线或者全是共线点从而引起栈中的点不足2然后导致访问越界
                      } else {
                          //如果不是共线就直接删除即可
                          stack.remove(stack.size() - 1);
                      }
                  }
              }
              //最后栈中的元素就是凸包顶点
              return stack;
          }
      
          //极角排序
          private ArrayList<Point> polarAngleSorted(Point re, Point[] points) {
              ArrayList<Point> result = new ArrayList<>();
              //先剔除参照点
              for (int i = 0; i < points.length; i++) {
                  if (points[i] != re) {
                      result.add(points[i]);
                  }
              }
              result.sort((Point o1, Point o2) -> {
                          //返回1代表o1大于o2,返回-1代表o2大
                          //计算两个点相对于参照点的极角
                          double angle1;
                          double angle2;
                          //先确定是否与参照点的横坐标相同相同就直接为1
                          if (o1.x - re.x == 0) {
                              angle1 = 1;
                          } else {
                              angle1 = (o1.y - re.y) / (o1.x - re.x);
                          }
                          if (o2.x - re.x == 0) {
                              angle2 = 1;
                          } else {
                              angle2 = (o2.y - re.y) / (o2.x - re.x);
                          }
                          //是否考虑精度问题，也就是不使用==，计算两者之间的差值小于一个极小数我们就认为它们相等
                          //因为默认排序是升序排列，角小的排前面，所以要返回-1。注意如果小于0那么就是越小越大。
                          //先确定两者的正负，负的要大，正(包括0，0就是与参照点的共线且位于右侧)的小
                          if ((angle1 < 0 && angle2 >= 0) || (angle2 < 0 && angle1 >= 0)) {
                              //如果两者异号,异号不存在相等的情况
                              if (angle1 > angle2) {//1为正表示o1小
                                  return -1;
                              } else {
                                  return 1;
                              }
                          } else {
                              //如果两者同号
                              //先确定是正还是负
                              if (angle1 >= 0) {
                                  //如果是正，那么就是小的小，大的大
                                  if (angle1 < angle2) {
                                      return -1;
                                  } else if (angle1 > angle2) {
                                      return 1;
                                  } else {
                                      //如果两个角相等也就是共线，我们保留离参照点远的点，并删除近的点.经过验证在比较中执行删除无法完成。
                                      //所以先计算与参照点的距离，因为参照点处于最下，且三点共线，所以我们只需要计算y的差值就行了，这样必然是正值不用取绝对值
                                      double d1 = o1.y - re.y;
                                      double d2 = o2.y - re.y;
                                      if (d1 < d2) {
                                          //离参照点近的放在前面
                                          return -1;
                                      } else if (d1 > d2) {
                                          return 1;
                                      }
                                      //因为会将这个点删除其实返回什么都无所谓
                                      return 0;
                                  }
                              } else {
                                  //如果为负
                                  //不相等时与上相反
                                  if (angle1 > angle2) {
                                      return -1;
                                  } else if (angle1 < angle2) {
                                      return 1;
                                  } else {
                                      //这里同上
                                      double d1 = o1.y - re.y;
                                      double d2 = o2.y - re.y;
                                      if (d1 < d2) {
                                          return -1;
                                      } else if (d1 > d2) {
                                          return 1;
                                      }
                                      return 0;
                                  }
                              }
      
                          }
                      }
              );
              return result;
          }
      
          //寻找参照点
          private Point findReference(Point[] points) {
              Point point = points[0];
              for (int i = 1; i < points.length; i++) {
                  //先保证是最下的点
                  if (point.y > points[i].y) {
                      point = points[i];
                  } else if (point.y == points[i].y) {
                      //如果y相等再取最左的
                 
                      if (point.x > points[i].x) {
                          point = points[i];
                      }
                  }
              }
              return point;
          }
      }
      ```





## 4.变治法

- 变治法的基本思想：变，将问题的实例变得更容易求解（就是问题的转换，比如的等价代换、化简等等）。治，对问题的实例进行求解。

- [变治法_不会程序的JAVA程序媛的博客-CSDN博客](https://blog.csdn.net/weixin_44019182/article/details/106795439)

- [算法-第6章-变治法(李静) - 道客巴巴 (doc88.com)](http://www.doc88.com/p-6708650225138.html)

- 变治法有三个变形：

  - 变换为同样问题的一个更简单或者更方便的实例----------我们称之为实例化简

    变换为同样实例的不同表现-------------------我们称之为改变表现

    变换为另一个问题的实例，这种问题的算法是已知的-----我们称之为问题化简。

### 4.1预排序

- 当解决某些问题时，直接解决耗费很大，但是如果保证有序情况下，就能够排除一些情况，从而提升。（我们其实应该可以称作预处理，比如现实中有些事直接处理可能比较复杂，过程难受，但是预先处理一下，做好规划，解决就比较得心应手。而这些预处理往往都是排序）
- 比如给定一个字符串，要寻找其中出现最多次数的字符。（这个一般被称作模式寻找问题。）
  - 如果使用蛮力法，进行一次全表扫描，依次进行统计（每次计数需要扫描一次辅助表中的元素）。最后找出辅助表中的次数的最大值的元素。所以效率为Θ(n^2).
  - 如果我们预先将元素进行排序,就只需要一次全表扫描,然后记录下连续连接次数最多的元素.效率Θ(n)
- 再比如说我们的查找问题:考虑在n个元素中查找某个给定值v.
  - 如果使用蛮力法-顺序查找,Ω(n).
  - 如果排好序,使用折半查找的思想,效率是Ω(longn).但是排序的代价nlogn.明显,两者之间存在一个值(查找的次数),当小于这个值时不排序优于排序,当大于这个值时,排序优于不排序.



### 4.2 平衡查找树

- 二叉树是每个结点最多有两个子树的树结构

- [笔试算法题（58）：二分查找树性能分析（Binary Search Tree Performance Analysis） - Leo C. - 博客园 (cnblogs.com)](https://www.cnblogs.com/leo-chen-2014/p/3762132.html)（里面有些思想可以学习一下）

- 二叉查找树:一棵空树,或是具有下列性质的二叉树:

  - 若左子树不空,则左子树上所有的结点的值均小于它的根节点的值.
  - 若右子树不空,则右子树上所有结点的值均大于它的根结点的值.
  - 左右子树也分别为二叉查找树.
  - 没有键值相等的结点.

- 二叉查找树的在构造时,很可能出现过分的偏于一边的现象,从而导致查找效率低的问题.为了保证查找效率就出现了平衡二叉查找树.

- **而为了解决二叉查找树可能出现退化为链表的问题，而使用构造平衡二叉查找树的思想就是：不断维护它的高度，而不改变它二叉树查找树的原问题形式。这就是变治法中的实例化简。包括红黑树也是。**

- AVL树-平衡二叉查找树:二叉查找树的平衡因子定义为,对于二叉查找树上任意结点,它的平衡因子是该结点左子树高度与右子树的高度差(空树的高度定义为-1)，所以计算平衡因子最好是直接使用高度直接计算，别被使用直接使用平衡因子计算搞晕了。

  <img src="..\图片\20211217154654.jpg" style="zoom:50%;" />

- AVL树是一棵二叉查找树,其中每个结点的平衡因子为0,或者1,或者-1.

- 如果插入的一个新节点使得一棵AVL树失去了平衡,用旋转对这棵树做一个变换,使其重新平衡化.

- AVL的旋转,是以某节点为根的子树的一个本地变换,该节点的平衡变成+2或-2;如果有若干个这样的节点,先找出最靠近新插入的叶子的不平衡节点,然后旋转以该节点为根的子树.(这个大致的场景应该是这样,当插入一个值是,检查发现离某棵或是某些子树不平衡了,这是因为因为这个新插入的点引起的,那么我们只需要将离这个点最近的不平衡子树条平衡,那么这个数就平衡了)

- 我们先约定：如果该节点的平衡因子小于0，则表示该节点的右子树高，如果大于0就表示左子树高。等于0表示一样高。（**该节点的平衡因子=左子树高度-右子树高度**。）

- AVL树的平衡旋转(4种类型):

  - [手把手教，手写AVL树 - 不止是编程 - 博客园 (cnblogs.com)](https://www.cnblogs.com/coding-nerver-die/p/10975599.html)
  
  - 右单转:（将待转节点的根及其右子树作为待转点的右子树，将待转点的右子树作为其根的左子树）
    - 前提-旋转是在一个新的键插入某棵树的根节点的左孩子的左子树中后发生的。在插入以前，树的根节点的平衡因子为+1(是0、-1也不会造成不平衡。)。插入后就成了+2。
    - 解决思路：我们将这个+2根节点的高度降1就行了，那么可以怎么办，它的左孩子的平衡因子是+1，那么直接将它的左孩子转为根，而将根转为右孩子，那么右孩子高度加1。左孩子高度降1，恰好平衡。（总之就是：将高的补到矮的一边达到平衡。）（后面的左单转同理。）
    - ![](..\图片\20211219162334.jpg)
  - 左单转：（将待转节点的根及其子树作为待转点的左子树，将待转点的左子树作为其根的右子树）
    - 前提-旋转是在一个新的键插入树的右孩子的右子树后发生的。在插入前,树的根的平衡因子是-1。插入后变成-2.
    - 解决方法：二叉树中连接根和它右子树的边向左旋转。
    - <img src="..\图片\20211219164944.jpg" style="zoom:50%;" />
  - 左右双转：
    - 前提：旋转是在新键值插入树的左孩子的右子树后发生的。插入前这棵树的根的平衡因子为+1
    - 解决方法：先对根的左孩子的右子树进行左旋，然后再对根的左孩子进行右旋。
    - <img src="..\图片\20211219182605.jpg" style="zoom:50%;" />
  - 右左双转：
    - 前提：旋转是在新建值插入树的右孩子的左子树后发生的。插入前这棵树的的平衡因子为-1.
    - 解决方法：先对右孩子的左子树右转，在对根的左孩子进行左转。
    - <img src="..\图片\20211219185624.jpg" style="zoom:50%;" />
  - AVL树的效率：
    - 设n个节点的AVL树的高度为h,则：LlognJ<=h<=1.4405log(n+2)-1.3277
    - 最差情况下，查找和插入操作效率属于Θ(logn).大量实验表明。平均高度大概是1.011logn+0.1(当n比较大时)，因此，在平均情况下，查找一棵AVL树需要比较的次数和使用折半查找的一个有序数组几乎时相同的。
    - avl树查找、添加、删除键操作的效率类型都属于对数级。
    - avl树的缺点时频繁的旋转，需要维护树的结点平衡以及总体上的复杂性，尤其是删除操作，阻碍了avl树成为实现字典的标准结构。
    - avl的调整可以边插入边调整，也可以一次性插入然后整体检查调整。
  
- 使用变治法的另一种思想解决二叉查找树的问题：2-3树(3阶b树)、2-3-4树（四阶b树）([多路查找树总结(2-3树、2-3-4树、B树、B+树、B*树)_Clover的博客-CSDN博客](https://blog.csdn.net/weixin_42893085/article/details/107824932))。

- B树是一种组织和维护外村文件系统非常有效的数据结构

  - 一棵m阶B树或者是一棵空树，或者是满足要求的m叉树：

    >- [资深老师讲B和B+树_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1e5411T77z?spm_id_from=333.337.search-card.all.click)
    >- 树中每个节点至多有m个孩子节点,每个节点最多含有m-1个关键字
    >- 除根节点外，其他非叶子节点至少有ceil(m/2)个孩子节点（比如3阶至少有2个孩子，该节点至少1个关键字）
    >- 若根节点不是叶子节点，则根节点至少有两个孩子节点。
    >- 每个节点中的关键字按大小顺序排列
    >- 所有外部节点都在同一层，B树是所有节点的平衡因子均等于0的多路查找树
    >- 插入节点一定是在叶子节点进行插入，插入极限时进行分裂（分裂都是分裂为一根二子）。分裂如果有父节点就加入，如果没有就新建一个父节点，树高度加一。递归进行。
    >- 什么时候分裂会使得树升高：**分裂节点没有父节点**，递归分裂时也是也是一样。所以B树的树高一般很稳定。不递归分裂到根，就不会升高。
    >- 删除节点：`删除准则：删除后除了根节点外其他节点的关键字数ceil(m/2)-1个，所以每次删除后需要检查是否满足条件`
    > - 删除叶子节点
    >   - 剩余节点数满足条件
    >   - 剩余节点数不满足最少数，就需要进行借取，先向父节点借取，然后检查父节点是否满足，如果不满足就向子节点借取，如果借取后子节点也不满足，那么就不借了，直接将这个两个子节点进行合并，合并后再检查这个父节点，父节点直接向父节点进行借取，借取后再次向前面那样检查，如果不满足就继续合并，直到根，如果根都不满足直接将根一起合并在子节点中。（合并的准则就是符合多路查找树的条件情况下，尽量降低树高优先）
    > - 删除非叶子节点
    >   - 先转换为删除叶子节点，然后就按照上面的两种情况进行处理。

- 2-3树是高度平衡树，允许节点最多包含来给你个关键字，**每个叶子到根的路径长度相同（即是叶子必须位于同一层）**。而每个节点的形态可能有两种：2-节点、3-节点

  - 2-节点，只包含一个键K和两个孩子，左孩子作为一棵所有键都小于K的子树的根，右孩子作为一棵所有键都大于K的子树的根。

  - 3-节点：包含两个有序键K1和K2(K1<K2)，并且有三个孩子：左边的孩子作一棵树所有键都小于K1的子树的根，中间孩子作为键值位于K1和K2之间的子树的根，最右边作为一棵树所有键都大于K2的子树的根。

  - 2-3树查找操作：

    - 从根节点开始，如果根是一个2节点，就把它当作一个二叉查找树操作。
    - 如果是一个三节点，就与两个键值比较在确定在哪棵子树递归查找。

  - 插入操作：

    - 如果一棵树非空（也就是整棵树的根，那个root如果不为空）就将这个键插入到叶子节点（就是左右均为空）中，置于具体在哪个点插入就需要通过查找确定；如果这棵树不为空，就新建一个叶子点，将新建作为其键值。

    - 根据新键值的大小关系，通过查找确定位置，把其插入到叶子节点中。

    - 如果该叶节点是2节点型的，则根据K是小于还是大于节点中原来的键，把K作为第一个键或者第二个键插入。

    - 如果该叶节点是3节点型的,需要分裂两个新叶子节点分别作为左右孩子,并按照二叉查找树的放置方式放置三个值到三个节点中(也就是将这三个节点按照二叉查找树构造成一棵新树).然后将这棵新树的根放到父节点中(如果这个根没有父节点就不需要,显然只有遇见root时才可能发生),其孩子变为父节点的孩子.显然如果提升后,父节点是3节点型同样需要继续分裂,这是一个递归过程.

    - 看完这张图基本就明白了:

      <img src="..\图片\20211220184955.jpg" style="zoom:50%;" />

  - 2-3树的高度的上下界

    - 设2-3树的高度为h:如果要使得该树包含的节点数n最小,那么树中每一个节点都是2节点的（意思是：相同输入规模n,全2节点型，节点的数目最多，为上界）
      $$
      于是:n>=1+2+4+...+2^h=2^{h+1}-1,即h<=log_2(n+1)-1.
      $$
      如果要使得该树包含的节点数n最大,那么树中每一个节点都是由3-节点构成的满树,每个节点包含两个键和三个孩子,（（意思是：相同输入规模n,全3节点型，节点的数目最少，为下界））于是:
      $$
      n<=2*1+2*3+....2*3^h=3^{h+1}-1,即h>=log_3(n+1)-1
      $$
      因此,2-3树高度h的上下界为:
      $$
      log_3(n+1)-1<=h<=log_2(n+1)-1
      $$
      
    - 
  
    
  
  - 2-3树节点分裂描述：
    
    - 预知前提：谨记2、3节点的类型形式，每种节点都有两种形式，有子节点与没有子节点。插入时第一次分裂仅仅是当前节点为3节点的无孩子的情况。而递归父节点分裂就只能是三节点有孩子型。
    - 对于无孩子情况，直接分裂新建节点左右节点就行。
      - 如果没有父节点,就将根的父置为空
      - 如果有父节点
        - 如果父节点类型是2节点型，那么就将分裂后的根值放在父节点的大值或最小值。
          - 如果分裂节点是父节点的左孩子，那么分裂后的左孩子仍在左孩子，右孩子放在父节点的中间孩子。
          - 如果分裂节点是父节点的右孩子，那么分裂后的左孩子放在父节点的中间孩子，右孩子仍在右孩子。
          - ![](..\图片\20211227165503.jpg)
        - 如果父节点类型是3节点型，那么将分裂后将根值放上让父节点分裂。父节点分裂后有直接的左右孩子。
          - 如果分裂点是父节点的左孩子。那么父节点分裂后的左孩子的左孩子是分裂点分裂后左孩子，右孩子是分裂点分裂后右孩子。而父节点分裂后的右孩子的左孩子是原来父节点的中间孩子，右孩子是原来父节点的右孩子。
          - 如果分裂点是父节点的右孩子。与上面相反。
          - 如果分裂点是父节点的中间孩子，那么就将分裂点分裂后的左孩子作为父节点分裂后的左孩子的右孩子，将右孩子作为父节点分裂后的右孩子的左孩子。
          - ![](..\图片\20211227184709.jpg)
    - 对于有孩子情况（也就是必然是某一个孩子分裂后的根向上导致的,所以就是上面的有父节点且父节点是3节点型情况。）
    - 综上：所以为了保证分裂节点能正确放置，所以需要先确定父节点的分裂状况，当父节点分裂完成之后需要返回其根。最后好当前分裂点的左右子节点放置。

##5.动态规划

##6.贪婪技术

