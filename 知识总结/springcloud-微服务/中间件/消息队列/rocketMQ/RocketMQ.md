# RocketMQ

## RocketMQ概述

## MQ

- message queue，是一种提供消息队列服务的中间件，是一套提供了**消息生产、存储、消费全过程API的软件系统**

- 用途无非以下

- **限流削峰**

  - MQ可以**将系统的超量请求暂存其中**，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。

    ![20220622171847](.\img\20220622171847.jpg)

- **异步解耦**

  - 上游系统对下游系统的调用若为同步调用。则会大大降低系统的吞吐量与并发度，且系统耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。
    - 可以通过观察订阅的方式将同步任务转换为异步任务。通过MQ进行状态维持。
    - 比如在秒杀系统中，在一瞬间必然系统的并发量很大，肯定不可能让所有请求打到系统上，我们可以使用MQ将订单存储起来，然后排队让库存系统进行减少。如果减少完，就直接将这些订单拒绝。就是让订单排序。

- 数据收集

  - 分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这时当前互联网平台的必备计数。通过MQ完成此类数据收集是最好的选择。

- 常见的MQ

  - activeMQ：

    - activeMQ是是哦那个Java语言开发一款MQ产品。现在公司用的很少。

  - RabbitMQ：

    - RabbitMQ使用ErLang语言开发的MQ。其吞吐量较kafaka与RocketMQ要低，且由于其不是Java开发，所以公司内部对其实现定制化开发难度较大。**对于Spring Cloud Netflix，其仅支持Rabbit MQ与Kafka**

  - Kafka

    - 是使用Java/Scala语言开发的一款MQ产品。其最大的特点就是高吞吐量。常用于大数据领域的实时计算、日志采集等场景。其没有遵循任何常见的MQ协议，二是使用自研协议。

  - Rocket

    - rocketMQ是使用Java语言开发的一款MQ产品。金国数年阿里双十一的考验，性能于稳定性非常高。其没有遵循任何常见的MQ协议，使用自研协议。SpringCloud Alibaba支持RabbitMQ、Kafka，减一使用RocketMQ

    ![20220622210240](.\img\20220622210240.jpg)

- **MQ常见协议**
  - 一般情况下MQ的实现是要遵循一些常规性协议的。
  - 常见协议
    - **JMS**
      - JMS,Java Messagsing Service。是Java平台上有关MOM（面向消息中间件）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、放、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。
      - PO/OO/AO/MO(面向过程、面向对象、面向切面、面向消息)
    - **STOMP**
      - Streaming Text Orientated Message Protocol,是一种MOM设计的简单文本协议。STOMP提供一个客户操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议。
    - AMQP
      - Advanced Message Queuing Protocol，一个提供统一消息服务的应用标准，是应用层协议的一个开放标准，是一个MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。RabbitMQ是该协议的典型实现。
  
- RocketMQ发展历程

  ![20220623090438](.\img\20220623090438.jpg)

## RocketMQ的安装与启动

### 基本概念

[RocketMQ角色详解之Broker_喜鹊先生Richard的博客-CSDN博客_broker rocketmq](https://blog.csdn.net/Cactus_Lrg/article/details/86706457)

- **消息：（Message）**

  - 消息是指，消息系统**所传输信息的物理载体**，**生产和消费数据的最小单位**，每条消息必须属于一个主题(Topic)-即是消息种类。

- **主题：（Topic）**

  - 表示一类消息的集合，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。
  - **一个生产者可以同时发送多种Topic的消息**，**而一个消费者只对某种特定的Topic感兴趣**，即只可以订阅和消费一种Topic的消息。（消息的产生是复杂的，根本不用区分，但是消息本身我们可以进行分类，然后按类别处理，这对于消息处理者-消费者是比较高效 的，因为它将消息种类的区分和消息的处理进行了解耦）

- **队列（Queue）**

  - **存储消息的物理实体**。**一个Topic中可以包含多个Queue**，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中**消息的分区**（Partition）。

  - **一个分区中的消息只能被*一个消费组中的消费者消费*，即是同一组的消费实例不能交叉访问分区。一个分区可以被不同的消费组中的某一个消费实例同时消费。**(注意：一个消费组中的消费者可以消费多个队列中的消息，但是一个队列只能被同一个组中的一个消费者消费，不同消费者组中的某一个消费者可以消费同一个队列。就是一个队列不能被同一组的消费者共享，可以被不同的进行共享。)

    ![20220623102351](.\img\20220623102351.jpg)

- **分片（Sharding）**

  - 分片不同于分区。在RocketMQ中，分片指的是存放响应Topic的Broker。每个分片中会创建出响应数量的分区，即Queue，**每个Queue的大小都是相同的**。

    ![20220623103802](.\img\20220623103802.jpg)

- **消息标识（MessageId/Key）**

  - RocketMQ中**每个消息拥有唯一的MessageId（可能重复，在并发极大的情况下、时间篡改、计数器重置）**，且可以携带具有业务标识的**Key**。**以方便对消息的查询**。不过需要注意的是，MessageId有两个：在生产者send（）消息时会自动生成一个MessageId（msgId）,当消息到达Broker后，Broker也会自动生成一个MessageId（offsetMsgId）。msgId、offsetMsgId、key都被称为消息标识。

    - mesId:由producer端生成，其生成规则为：

      producerIp+进程pid+MessageClientIDSetter类的ClassLoader的hashCode+当前时间+AutomicInteger自增计数器

    - offsetMsgId:由broker端生成，其生成规则为：brokerIp+物理分区的offset（就是信息在队列中的偏移量）

    - key:由用户指定的业务相关的唯一标识

    - 通过这些ID我们可以对消息进行溯源。

### 系统架构

- 主要分为四个部分：四个部分都是集群部署

  - **Producer**

    - 消息生产者，负责消息生产。Producer通过MQ的负载均衡模块选择响应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。

    - RocketMQ中**消息生产者都是以生产者组**的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。

  - **Consumer**

    - 消息消费者，负责消费消息。一个消息消费者会从**Broker服务器**中获取到消息，并对消息进行相关业务处理。
    - RocketMQ中的消息消费者都是以消费者组的形式出现的。消费组是同一类消费者的集合，**这类Consumer消费的是同一个Topic类型的消息**。消费者组使得在***消息消费方面***，实现负载均衡和容错的目标变得非常容易。
    - **负载均衡：就是指将一个Topic中的不同的Queue平均分配给同一个Consumer Group，不同的Consumer。并不是将消息负载均衡**
    - **容错：一个Consuemr管理，该Consumer Group中的其他Consumer可以接着消费元Consuermer消费的Queue** 
    - 注：生产者是向Broker中放资源，所以是在访问Broker，所以是Broker端实现负载均衡。而消费者是要拿取消息，所以同样是访问Broker，同样是由Broker实现负载均衡。（**故有下：Broker既有面向生产端的负载均衡策略，又有面向消费端的负载均衡策略**）
    - 注：这里的消费端负载均衡（**回顾前面的消费规则**）仅仅只是说是队列的负载能够均匀分配，但实际消息是否被均匀分配是不确定的。
    - 注：**Consumer Group中的Consumer数量应该小于等于订阅Topic的Queue数量**。如果超出Queue数量，则多出的Consumer将不能消费消息。一个Topic类型的消息可以被多个消费者组同时消费。
    - 注：**一个消费者组中的消费者必须订阅完全相同的Topic，消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息**（----这两点都可以避免出现同一组

    

  
