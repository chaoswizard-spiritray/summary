# Java克隆

## 克隆由来

- 四种对象创建方式：new 、克隆、反射、反序列化。
- [深入理解java中的拷贝机制_java_脚本之家 (jb51.net)](https://www.jb51.net/article/105651.htm)



## 具体使用步骤

- 实现Cloneable接口，重写clone方法

```tex
 * String 类型克隆功能不可用，因为我们的字符串的值为一个final char value[]，
 * 众所周知，数组也是一个引用，它的实体要么在堆区中要么在常量池中。而字符串字面量是放在常量池中的，
 * 而String又是一个引用，所以我们新建一个字符串，实际就是在局部变量表中声明了一个变量名，这个变量名指向
 * 堆区中String空间，这个空间存的数据其实就一个，就是数组的引用，而这个引用指向的是常量池中的字符串字面量。
 * 那么所以为什么String不提供拷贝功能，没有意义，因为拷贝出来的要么是局部变量直接指向常量池地址，要么就是在
 * 堆区中多一个String空间指向常量池引用。所以不如直接共用一个String实际空间就行。
 * 总而言之，string实例是唯一的，故不可拷贝。
 * https://blog.csdn.net/freejs/article/details/84362279(克隆相关方法详解)
 *克隆并不会调用任何构造函数以及set方法。
```

- 使用深度克隆存在的问题：需要重复实现Cloneable接口以及重写clone方法，如果需求改变需要重复的改变clone方法。

## 使用IO流进行深度克隆（避免了上述的实现接口的缺点）

- 相关类
  - ByteArrayOutputStream
    - 这个类实现了一个输出流，其中的数据内写入一个byte数组，缓冲区会随着数据的不断写入而自动增长。可使用toByteArray()和toString()获取数据
    - 这个流不需要关闭，就算执行了close这个流仍然可以调用不会报IO异常。
  - ByteArrayInputStream
    - 与上类同。
  - ObjectOutputStream（可以将类输出到指定数据源，不仅仅是文件）
    - 序列化中已经讲过不再赘述。
  - ObjectInputStream



## Clone底层C++代码

- 个人猜测疑问
  - clone不调用构造器，是不是直接通过底层指针进行相同大小的空间进行移动然后进行复制。所以并不在意具体的类型。从这点上就不需要使用构造进行初始化。获取的也是两个对象.但是深拷贝使用set仍然是无法避免的.

## 为什么会有使用clone付出代价比new小的说法？

- 假设一个对象的创建需要重重依赖，那就需要不断地new很多地不同地对象，那么就需要加载类信心，然后调用他们的构造器，初始化域。克隆不会调用构造器，那么就不会这么麻烦。从这点上结合个人猜测说效率确实要高于new。

  

