# Java IO Stream

## 1、文件

- 概念：保存数据的地方，音频、图片、pdf、docx等等。

- 文件流：文件再程序中是以流的形式来操作的

  - ![](.\图片\20211010083625.jpg)
  - 个理解：流就是一辆车，你只需要将将数据装载到车里，并给他指明终点，它就知道将数据输出。反过来读取也是如此。（注意Java中的各种网络通信IO模型）

- 常用的文件操作

  - 创建文件对象相关构造器和方法

    - 相关方法

      ![](.\图片\20211010084620.jpg)

    - 使用createNewFile方法的作用就是将内存中的File对象持久化到物理磁盘上。

    - 详情看手册、注意线程安全与否。

  - 目录操作和文件删除

    - mkdir创建一级目录、mkdirs创建多级目录、delete删除空目录或文件。

## 2、IO流原理及流的分类

- Java IO流

  - IO用于处理数据传输，如文件读写、网络通讯
  - Java程序中，对于数据的输入输出操作以Stream的方式进行
  - 具体以及相关的操作数据输入输出的接口、类至于java.io包下
  - 输入流：读取外部数据（磁盘、光盘、网卡等存储设备的数据）到程序（内存）中
  - 输出流：将程序（内存）数据输出到磁盘、光盘、网卡等存储设备中

- IO流分类

  - 按读写操作是否查询字符集（码表）：字节流（不查）、字符流（查）：字节流是流的最基本的流。
  - 按数据流的流向：输入流、输出流（具体到输入输出目标就有更多的输入输出流子类）
  - 按流的角色的不同分为：节点流、处理流、包装流
  - 各种类之间的关系见下
  - ![](.\图片\20211010101502.jpg)
  - ![字节流](.\图片\2017510143717263.png)
  - ![字符流](.\图片\2017510143811976.png)

- IO 流注意点：

  - **1. 基类
    **

    InputStream与OutputStream是所有字节型输入输出流的基抽象类,同时也是适配器(原始流处理器)需要适配的对象,也是装饰器(链接流处理器)装饰对象的基类.

    **2. 原始流处理器**

    原始流处理器接收Byte数组对象,String对象,FileDescriptor对象将其适配成InputStream,以供其他装饰器使用,他们都继承自InputStream 包括如下几个:

    ByteArrayInputStream: 接收Byte数组为流源,为多线程通信提供缓冲区操作功能

    FileInputStream: 接收一个File作为流源,用于文件的读取

    PipedInputStream: 接收一个PipedOutputStream,与PipedOutputStream配合作为管道使用

    StringBufferInputStream: 接收一个String作为流的源(已弃用) 

    **3. 链接流处理器**

    链接流处理器可以接收另一个流处理器(InputStream,包括链接流处理器和原始流处理器)作为源,并对其功能进行扩展,所以说他们是装饰器.

    1) FilterInputStream继承自InputStream,是所有装饰器的父类,FilterInputStream内部也包含一个InputStream,这个InputStream就是被装饰类--一个原始流处理器,它包括如下几个子类:

    BufferedInputStream: 用来将数据读入内存缓冲区,并从此缓冲区提供数据

    DataInputStream: 提供基于多字节的读取方法,可以读取原始数据类型(Byte, Int, Long, Double等等)

    LineNumberInputStream: 提供具有行计数功能的流处理器

    PushbackInputStream: 提供已读取字节"推回"输入流的功能

    2) ObjectInputStream: 可以将使用ObjectOutputStream写入的基本数据和对象进行反串行化

    3) SequenceInputStream: 可以合并多个InputStream原始流,依次读取这些合并的原始流 

- 流和文件的关系：

  - 流是数据源之间的数据运输者
  - 文件是数据源的一种

- 字节流与字符流的关系

  - 字节流对于所有的文件输入输出都有效，是最底层的流。
  - 字符流仅仅是为了方便文字的处理，所以对于文本文字处理最好使用字符流。不给人看的二进制文件就别用字符流进行处理。（视频、音频、doc、pdf）

- **各种子流的的大致理解**

  - 流的底层都是使用最基本的字节流完成操作，而那些流无非划分为两种
    - 根据不同的数据源的进行处理扩展
    - 根据处理功能进行扩展
    - 注：这两者并不冲突，只是着重点不一样，在具体的场景有具体的适用方案

- 常用的字节输入流

  - InputStream（所有字节输入流的超类）
  - 常用子类
    - FileInputStream:文件字节输入流
    - BufferedInputStream:缓冲字节输入流
    - ObjectInputStream：对象字节输入流
    - ![](.\图片\20211010104426.jpg)
    - Closeable与AutoCloseable就是流关闭接口。OutputStream多一个Flushable接口
    - 注意OutputStream使用write(byte[])时，因为是将整个数组写出，所以可能导致，文件损坏。
  
- 常用字符流

  - 体系结构类似字节流
  - FileReader与FileWriter

## 3、节点流和处理流

- 节点流
  - 节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter
- 处理流
  - 也叫做包装流，是“连接”在已存在的流（节点流或者处理流）之上，为其提供更为强大的读写功能，如：BufferedReader、BufferedWriter。
- <img src="\图片\20211010143915.jpg" style="zoom:150%;" />
- 节点流和处理流的区别和联系
  - 节点流是底层流/低级流，直接跟数据源相接
  - 处理流包装节点流，即可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。
  - 处理流对节点流进行包装，使用了装饰者设计模式，不会直接与数据源相连。
  - 处理流的功能主要体现在：
    - 性能提高：主要增加缓冲的方式提高输入输出的效率
    - 操作便捷：处理流可提供一系列便捷方法来输入输出大批量的数据，使用更加灵活方便。
  - 所以使用包装流为什么一般先关闭包装流再关闭底层流。其实具体怎么关闭，自己看源码。节点流每次新建一个对象会开辟一个channel，而包装流仅仅只是建立在节点流之上，所以包装流的关闭一般是假关闭，仅仅只是执行关闭之前为保证安全这个包装流应该要执行什么操作，节点流关闭才是正真的将channel关闭，具体关闭源码需要追寻本地方法。以BufferedOutputStream为例，它的close仅仅只是flush了一下，将数据写出，并没有进行关闭，而节点流的close才会进行关闭。又比如BufferedInputStream会调用节点的关闭方法，这又和BufferedOutputStream不一致了。所以建议先关外层再关内层，以防不一致。
- 对象流：ObjectInputStream与ObjectOutputStream。将基本数据类型或者对象进行序列化以及反序列化。
  - ![](\图片\20211011172612.jpg)
  - ![](\图片\20211011172939.jpg)
  - 反序列化数据的顺序需要和序列化数据的顺序一致。
  - 序列化对象时，默认将所有的属性进行序列化，除了static与transient
  - 序列化对象时，要求属性类型也需要实现序列化接口
  - 序列化具有可继承性
- 标准输入输出流：System.in、System.out(控制台输入输出，System.in实际使用的流是BufferedInputStream，System.out使用的是PrintStream)
- **转换流(为了将字节流转换字符流），IO本质只有一种流就是字节流。开始只有字节流以及它的节点流和处理流，照理说完全能处理任何数据了，但是偏偏有文字这种东西需要显示和存储，各国的文字编码又不一样，存取的时候每次都需要进行字节流的字符解析，很麻烦，于是就按照字节流的概念和体系结构，单独将其提取出来，创建字符流的概念。但是问题来了，这个字符流就是一个概念而已，底层只有字节流，而它字符流要做的不过就是根据需求将字节转换为相应的字符。（所以从这点可以看出字节流与字符流看起来相似，实际上不如说字符流就是字节流的增强器。)现在概念提出来了,新的问题来了，字符流相对于用户应该作为一个独立的概念使用，这样也便于扩展，如何将两者联系起来，从思维上不可能说我每次创建一个字符流要传入一个字节节点流，这不符合体系结构，内聚性感觉也不够高，也显得两者之间的关系混乱，怎么办？那我们就单独抽一个字符流子类出来用于连接两者，它就只用于连接两者，到时候创建其他字符节点流时，就使用这个连接类来构造就行了，这不就没有打破定义好的体系结构概念**
- ***具体Java的实现思路：将字符流划分为两类-节点流、处理流。而节点流顶层只有一类就是：InputStreamReader与OutputStreamWriter。这个就是实现将字节转换为字符的一系列操作。为了满足整体的体系结构以及将常用数据源抽出来于是有了新的节点流，如FileReader，这些流都是继承自转换流。他们用于特定的场景，遇见这种场景时你就能直接使用。所以有些参数不能自定义，灵活性不如转换流。处理流：本质目的就是对节点流的处理功能进行增强，这些不同的功能能够嵌套（也可以说处理流就是对某个流进行处理功能增强），所以在构造处理流时需要传入一个字符流。***
- 注意：具体思路参考流的体系结构图分析
  - InputStreamReader
    - Reader的子类，可以将InputStream包装成Reader
  - OutputStreamWriter
    - Writer的子类，实现将OutputStream包装为Writer。
  - 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文乱码，
  - 将字节流构造为转换流时可以指定字符集。
- 打印流
  - PrintStream和PrintWriter，只有输出流没有输入流，可以指定打印到的数据位置。

##  4、Properties类

- load：加载配置文件的键值对到Properties对象
- list：将数据显示到指定设备、流对象
- getProperties(key)：根据键获取值
- setProperties(key,value):设置键值对到Properties对象
- store:将Properties中的键值对存储到配置文件，保存信息到配置文件中是，如果有中文，会存储为Unicode码。
- 使用这个类既能够读取配置文件也能够进行配置文件的修改、添加、删除键值对以及配置文件的创建。
- 该类是HashTable的子类，所以底层主要就是HashTable的实现。

